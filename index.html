<!DOCTYPE html>
<html lang="en">
<body>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #111;
            font-family: Arial, sans-serif;
            color: #fff;
        }
        
        #game-container {
            position: relative;
        }
        
        canvas {
            display: block;
            margin: 0 auto;
            border: 2px solid #333;
        }
        
        .instructions {
            max-width: 800px;
            margin: 20px auto;
            padding: 15px;
            background-color: rgba(0, 20, 40, 0.8);
            border-radius: 8px;
        }
        
        h1 {
            text-align: center;
            color: #00aaff;
        }
        
        h2 {
            color: #00ccff;
        }
    </style>
    <div id="game-container">
        <h1>NEON SURVIVOR</h1>
        
        <div id="canvas-container"></div>
        
        <div class="instructions">
            <h2>How to Play</h2>
            <p><strong>Movement:</strong> WASD or Arrow Keys</p>
            <p><strong>Aim:</strong> Mouse pointer</p>
            <p><strong>Shooting:</strong> Automatic</p>
            <p><strong>Upgrade Selection:</strong> Mouse click or number keys (1-3)</p>
            <p><strong>Restart (Game Over):</strong> Space bar</p>
            
            <h2>Game Mechanics</h2>
            <p>Survive as long as possible by defeating enemies. Collect experience gems to level up and choose upgrades.</p>
            <p>Blue gems are experience, red crosses are health pickups.</p>
            <p>There are three types of enemies:
                <br>- Red triangles (basic)
                <br>- Purple arrows (fast)
                <br>- Orange circles (tank)
            </p>
            <p>There are three weapon types you can unlock:
                <br>- Laser (green)
                <br>- Plasma (yellow)
                <br>- Wave (purple)
            </p>
        </div>
    </div>
    
    <!-- Load P5.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    
    <!-- Load game script -->
    <script>
        // Neon Survivor - A Vampire Survivors style game with futuristic theme
// All assets created programmatically with P5.js

const weaponEvolutions = {
    laser: {
        name: 'Phasor',
        description: 'Fires a continuous, wide beam of energy that pierces through all enemies.',
        requiredPassive: 'High-Energy Capacitor',
    },
    plasma: {
        name: 'Singularity Cannon',
        description: 'Creates a black hole on impact, pulling in and damaging nearby enemies.',
        requiredPassive: 'Graviton Emitter',
    },
    wave: {
        name: 'Resonance Blaster',
        description: 'Fires expanding energy rings that bounce off the edges of the screen.',
        requiredPassive: 'Sonic Amplifier',
    }
};

let player;
let enemies = [];
let projectiles = [];
let enemyProjectiles = [];
let particles = [];
let pickups = [];
let damageNumbers = [];
let gameTime = 0;
let score = 0;
let level = 1;
let experience = 0;
let experienceToNextLevel = 100;
let gameState = 'mainmenu'; // 'mainmenu', 'playing', 'upgrade', 'gameover', 'upgrades'
let upgradeOptions = [];
let permanentCurrency = 0;
let globalUpgrades = {};

const ships = [
    {
        name: 'Alpha',
        unlockCost: 0,
        weapon: 'laser',
        trait: 'None',
        description: 'The standard ship, balanced in all aspects.'
    },
    {
        name: 'Beta',
        unlockCost: 500,
        weapon: 'plasma',
        trait: '+10% speed',
        description: 'A faster ship with a powerful plasma weapon.'
    },
    {
        name: 'Gamma',
        unlockCost: 1000,
        weapon: 'wave',
        trait: 'Starts with an extra projectile',
        description: 'A ship with a wide-range wave weapon and extra firepower.'
    }
];
let unlockedShips = ['Alpha'];
let currentShip = ships[0];

let availableUpgrades = [
  { name: 'Speed', description: 'Increase movement speed', maxLevel: 5, id: 'speed' },
  { name: 'Damage', description: 'Increase projectile damage', maxLevel: 5, id: 'damage' },
  { name: 'Fire Rate', description: 'Increase firing speed', maxLevel: 5, id: 'fireRate' },
  { name: 'Projectile Size', description: 'Increase projectile size', maxLevel: 5, id: 'projectileSize' },
  { name: 'Projectile Speed', description: 'Increase projectile velocity', maxLevel: 5, id: 'projectileSpeed' },
  { name: 'Health', description: 'Increase max health', maxLevel: 5, id: 'health' },
  { name: 'Multishot', description: 'Fire additional projectiles', maxLevel: 3, id: 'multishot' },
  { name: 'High-Energy Capacitor', description: 'Required for Phasor evolution', maxLevel: 1, id: 'highEnergyCapacitor' },
  { name: 'Graviton Emitter', description: 'Required for Singularity Cannon evolution', maxLevel: 1, id: 'gravitonEmitter' },
  { name: 'Sonic Amplifier', description: 'Required for Resonance Blaster evolution', maxLevel: 1, id: 'sonicAmplifier' }
];
const globalUpgradeTypes = {
  bonus_stats: { name: 'Bonus Stats', description: 'Start with a permanent bonus to your stats.', cost: 100, maxLevel: 5 },
  new_items: { name: 'New Items', description: 'Unlock new items to find in the level-up pool.', cost: 250, maxLevel: 3 },
  reroll_ability: { name: 'Reroll', description: 'Gain the ability to reroll your upgrade choices.', cost: 500, maxLevel: 3 }
};
let activeSynergies = [];
let synergyAlerts = [];
const synergies = [
  {
    name: 'Supernova',
    description: 'Projectiles create a damaging explosion on impact',
    required: ['Multishot', 'Projectile Size'],
    effect: (player) => {
      player.synergies.supernova = true;
    }
  }
];
let weaponTypes = ['laser', 'plasma', 'wave'];
let evolvedWeapons = {};
let currentWeapon = 'laser';
let gameFont;
let starfield = [];
let screenShake = 0;
let kills = 0;
let boss = null;

// Color palette
const COLORS = {
  background: '#0a0a1a',
  player: '#00ccff',
  playerShadow: '#0066ff',
  enemy1: '#ff0066',
  enemy2: '#cc00ff',
  enemy3: '#ff9900',
  boss: '#ff6600', // A fiery orange for the boss
  projectileLaser: '#00ffcc',
  projectilePlasma: '#ffcc00',
  projectileWave: '#cc66ff',
  experience: '#00ff99',
  health: '#ff3366',
  text: '#ffffff',
  uiBackground: 'rgba(0, 20, 40, 0.8)',
  uiHighlight: '#00aaff'
};

let audioContext;
let masterGain;

function playSound(type, options = {}) {
    if (!audioContext) return;

    const now = audioContext.currentTime;
    const { frequency = 440, duration = 0.1, volume = 0.5, attack = 0.01, decay = 0.05, sustain = 0.1, release = 0.1, wave = 'triangle' } = options;

    const osc = audioContext.createOscillator();
    const gainNode = audioContext.createGain();

    osc.connect(gainNode);
    gainNode.connect(masterGain);

    osc.type = wave;
    osc.frequency.setValueAtTime(frequency, now);

    // ADSR Envelope
    gainNode.gain.setValueAtTime(0, now);
    gainNode.gain.linearRampToValueAtTime(volume, now + attack);
    gainNode.gain.linearRampToValueAtTime(volume * sustain, now + attack + decay);
    gainNode.gain.linearRampToValueAtTime(0, now + duration);

    osc.start(now);
    osc.stop(now + duration);
}

function setup() {
  let canvas = createCanvas(800, 600);
  canvas.parent('canvas-container');
  loadProgress();
  strokeJoin(ROUND);
  strokeCap(ROUND);

  // Initialize Web Audio
  try {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioContext.createGain();
    masterGain.gain.value = 0.5; // Master volume
    masterGain.connect(audioContext.destination);
  } catch (e) {
    console.error('Web Audio API is not supported in this browser');
  }

  // Convert color strings in COLORS to p5.Color objects
  for (let key in COLORS) {
    COLORS[key] = color(COLORS[key]);
  }

  // Setup starfield with parallax
  starfield = {
      near: [],
      mid: [],
      far: [],
      nebulas: []
  };
  for (let i = 0; i < 50; i++) { // Near stars
      starfield.near.push({ x: random(width), y: random(height), size: random(2, 4), speed: 1 });
  }
  for (let i = 0; i < 100; i++) { // Mid stars
      starfield.mid.push({ x: random(width), y: random(height), size: random(1, 2.5), speed: 0.5 });
  }
  for (let i = 0; i < 200; i++) { // Far stars
      starfield.far.push({ x: random(width), y: random(height), size: random(0.5, 1.5), speed: 0.2 });
  }
  // Generate a few nebulas
    for (let i = 0; i < 3; i++) {
        starfield.nebulas.push({
            x: random(width),
            y: random(height),
            size: random(200, 400),
            color: color(random(50, 100), random(20, 50), random(80, 150), 30),
            noiseSeed: random(1000)
        });
    }


  // Initialize player
  player = new Player(width / 2, height / 2);

  // Start the game
  gameState = 'playing';
}

function DamageNumber(x, y, amount) {
  this.x = x;
  this.y = y;
  this.amount = amount;
  this.lifetime = 60; // 1 second
  this.alpha = 255;
}

function draw() {
  background(COLORS.background);

  if (gameState === 'playing') {
    updateGame();
    drawGame();
  } else if (gameState === 'upgrade') {
    drawGame(); // Draw the game behind the upgrade screen
    drawUpgradeScreen();
  } else if (gameState === 'gameover') {
    drawGame();
    drawGameOverScreen();
  } else if (gameState === 'mainmenu') {
    drawMainMenu();
  } else if (gameState === 'upgrades') {
    drawUpgradeStore();
  } else if (gameState === 'ship_selection') {
    drawShipSelection();
  }

  // Apply screen shake
  if (screenShake > 0) {
    translate(random(-screenShake, screenShake), random(-screenShake, screenShake));
    screenShake *= 0.9;
    if (screenShake < 0.5) screenShake = 0;
  }
}

function drawDamageNumbers() {
  for (let dn of damageNumbers) {
    push();
    fill(255, dn.alpha);
    textSize(16);
    textAlign(CENTER);
    text(floor(dn.amount), dn.x, dn.y);
    pop();
  }
}

function updateGame() {
  // Update game time (seconds)
  gameTime += 1/60;

  // Update player
  updatePlayer();

  // Update projectiles
  updateProjectiles();

  // Update enemies
  updateEnemies();

  // Update enemy projectiles
  updateEnemyProjectiles();

  // Update particles
  updateParticles();

  // Update pickups
  updatePickups();

  // Update damage numbers
  updateDamageNumbers();

  // Update synergy alerts
  updateSynergyAlerts();

  // Spawn enemies
  if (frameCount % Math.max(30, 120 - level * 5) === 0) {
    spawnEnemy();
  }

  // Check for weapon evolution
  if (frameCount % 60 === 0) { // Check every second
    checkForWeaponEvolution();
  }

  // Spawn boss at intervals
  if (floor(gameTime) > 0 && floor(gameTime) % 180 === 0 && boss === null) {
    spawnBoss();
  }

  // Check for level up
  if (experience >= experienceToNextLevel) {
    levelUp();
  }
}

function updateDamageNumbers() {
  for (let i = damageNumbers.length - 1; i >= 0; i--) {
    let dn = damageNumbers[i];
    dn.y -= 1; // Move up
    dn.lifetime--;
    dn.alpha = 255 * (dn.lifetime / 60); // Fade out

    if (dn.lifetime <= 0) {
      damageNumbers.splice(i, 1);
    }
  }
}

function updatePlayer() {
  player.update();
}


function fireEnemyProjectile(enemy) {
  let angle = atan2(player.y - enemy.y, player.x - enemy.x);
  enemyProjectiles.push({
    x: enemy.x,
    y: enemy.y,
    vx: cos(angle) * 4,
    vy: sin(angle) * 4,
    size: 8,
    damage: enemy.damage,
    color: enemy.color,
    lifetime: 240 // 4 seconds
  });
}

function fireBossProjectile(enemy) {
  let numProjectiles = 12;
  let angleIncrement = TWO_PI / numProjectiles;

  for (let i = 0; i < numProjectiles; i++) {
    let angle = i * angleIncrement;
    enemyProjectiles.push({
      x: enemy.x,
      y: enemy.y,
      vx: cos(angle) * 3,
      vy: sin(angle) * 3,
      size: 12,
      damage: enemy.damage,
      color: enemy.color,
      lifetime: 300
    });
  }
}

function updateEnemyProjectiles() {
  for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
    let p = enemyProjectiles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.lifetime--;

    // Check for collision with player
    if (dist(p.x, p.y, player.x, player.y) < p.size + player.size) {
      player.health -= p.damage;
      player.invulnerable = 30;
      screenShake = 5;
      playSound('playerHit', { frequency: 100, wave: 'sawtooth', volume: 0.6, duration: 0.2 });
      enemyProjectiles.splice(i, 1);
      continue;
    }

    if (p.lifetime <= 0 || p.x < 0 || p.x > width || p.y < 0 || p.y > height) {
      enemyProjectiles.splice(i, 1);
    }
  }
}

function updateProjectiles() {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    let p = projectiles[i];
    p.update();

    // Check for collision with enemies
    for (let j = enemies.length - 1; j >= 0; j--) {
      let e = enemies[j];
      let distance = dist(p.x, p.y, e.x, e.y);

      if (distance < p.size + e.size) {
        // Hit enemy
        e.health -= p.damage;
        damageNumbers.push(new DamageNumber(e.x, e.y, p.damage));
        playSound('enemyHit', { frequency: 220, wave: 'square', volume: 0.2, duration: 0.05 });

        // Create hit particles
        for (let k = 0; k < 8; k++) {
          let angle = random(TWO_PI);
          particles.push(new Particle(p.x, p.y, {
            vx: cos(angle) * random(1, 3),
            vy: sin(angle) * random(1, 3),
            size: random(2, 4),
            lifetime: random(10, 20),
            color: e.color,
            alpha: 255
          }));
        }

        // Handle weapon-specific effects
        if (player.synergies.supernova || p.type === 'plasma' || p.type === 'Singularity Cannon') {
          let explosionRadius = (p.type === 'plasma' ? 80 : 60) * p.projectileSize;
          let explosionDamage = p.damage * (p.type === 'plasma' ? 0.5 : 0.3);

          if (p.type === 'Singularity Cannon') {
              // Create a black hole
              particles.push(new Particle(p.x, p.y, {
                  vx: 0, vy: 0,
                  size: 100,
                  lifetime: 300,
                  color: color(0),
                  damaging: true,
                  damage: p.damage * 0.1,
                  pulls: true
              }));
              projectiles.splice(i, 1);
              continue;
          }

          for (let k = enemies.length - 1; k >= 0; k--) {
            if (k === j) continue;
            let otherEnemy = enemies[k];
            if (dist(p.x, p.y, otherEnemy.x, otherEnemy.y) < explosionRadius) {
              otherEnemy.health -= explosionDamage;
              damageNumbers.push(new DamageNumber(otherEnemy.x, otherEnemy.y, explosionDamage));
              if (otherEnemy.health <= 0) {
                killEnemy(k);
              }
            }
          }
        }

        if (p.type === 'plasma' || (player.synergies.supernova && p.type !== 'laser' && p.type !== 'Phasor')) {
          projectiles.splice(i, 1);
        } else if (p.type === 'laser' || p.type === 'Phasor') {
          p.pierce--;
          if (p.pierce <= 0) {
            projectiles.splice(i, 1);
          }
        } else {
          projectiles.splice(i, 1); // Remove non-laser projectiles on hit
        }

        // Check if enemy is dead
        if (e.health <= 0) {
          killEnemy(j);
        }

        if (projectiles[i] !== p) {
          break; // Exit enemy loop if projectile was removed
        }
      }
    }

    // Remove projectile if out of bounds or expired
    if (p.isOffscreen()) {
      projectiles.splice(i, 1);
    }
  }
}

function updateEnemies() {
  for (let i = enemies.length - 1; i >= 0; i--) {
    let e = enemies[i];
    e.update(player);

    // Check for collision with player
    if (player.invulnerable <= 0) {
      let distance = dist(e.x, e.y, player.x, player.y);
      if (distance < e.size + player.size * 0.8) {
        // Player takes damage
        player.health -= e.damage;
        player.invulnerable = 30; // Half a second of invulnerability
        playSound('playerHit', { frequency: 100, wave: 'sawtooth', volume: 0.6, duration: 0.2 });

        // Screen shake
        screenShake = 10;

        // Create hit particles
        for (let j = 0; j < 15; j++) {
          let angle = random(TWO_PI);
          particles.push(new Particle(player.x, player.y, {
            vx: cos(angle) * random(2, 5),
            vy: sin(angle) * random(2, 5),
            size: random(3, 6),
            lifetime: random(15, 30),
            color: COLORS.player,
            alpha: 255
          }));
        }

        // Check if player is dead
        if (player.health <= 0) {
          gameOver();
          return;
        }
      }
    }
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    p.update();

    // Check for collision with player if particle is damaging
    if (p.damaging && player.invulnerable <= 0) {
      if (dist(p.x, p.y, player.x, player.y) < p.size + player.size / 2) {
        player.health -= p.damage;
        player.invulnerable = 30;
        screenShake = 3;
        // Do not remove the particle, it can damage multiple times
      }
    }

    if (p.pulls) {
        for (let enemy of enemies) {
            let d = dist(p.x, p.y, enemy.x, enemy.y);
            if (d < p.size * 2) {
                let angle = atan2(p.y - enemy.y, p.x - enemy.x);
                enemy.x += cos(angle) * 2;
                enemy.y += sin(angle) * 2;
            }
        }
    }

    if (p.isDead()) {
      particles.splice(i, 1);
    }
  }
}

function updatePickups() {
  for (let i = pickups.length - 1; i >= 0; i--) {
    let p = pickups[i];

    // Move pickup toward player if close enough
    let distance = dist(p.x, p.y, player.x, player.y);
    if (distance < 150) {
      let angle = atan2(player.y - p.y, player.x - p.x);
      let magnetSpeed = map(distance, 0, 150, 8, 2);
      p.x += cos(angle) * magnetSpeed;
      p.y += sin(angle) * magnetSpeed;
    }

    // Check for collision with player
    if (distance < player.size + p.size) {
      // Collect pickup
      if (p.type === 'experience') {
        experience += p.value;
        playSound('pickupExp', { frequency: 880 + level * 20, wave: 'sine', volume: 0.2, duration: 0.05 });

        // Create collection particles
        for (let j = 0; j < 8; j++) {
          let angle = random(TWO_PI);
          particles.push(new Particle(p.x, p.y, {
            vx: cos(angle) * random(1, 3),
            vy: sin(angle) * random(1, 3),
            size: random(2, 4),
            lifetime: random(15, 30),
            color: COLORS.experience,
            alpha: 200
          }));
        }
      } else if (p.type === 'health') {
        player.health = min(player.maxHealth, player.health + p.value);
        playSound('pickupHealth', { frequency: 440, wave: 'sine', volume: 0.4, duration: 0.2 });

        // Create collection particles
        for (let j = 0; j < 8; j++) {
          let angle = random(TWO_PI);
          particles.push(new Particle(p.x, p.y, {
            vx: cos(angle) * random(1, 3),
            vy: sin(angle) * random(1, 3),
            size: random(2, 4),
            lifetime: random(15, 30),
            color: COLORS.health,
            alpha: 200
          }));
        }
      }

      // Remove pickup
      pickups.splice(i, 1);
    }

    // Make pickup float
    p.y += sin(frameCount * 0.1 + p.x) * 0.3;

    // Create floating particles
    if (frameCount % 10 === 0) {
      particles.push(new Particle(p.x + random(-p.size/2, p.size/2), p.y + random(-p.size/2, p.size/2), {
        vx: random(-0.5, 0.5),
        vy: random(-1, -0.5),
        size: random(1, 3),
        lifetime: random(10, 20),
        color: p.type === 'experience' ? COLORS.experience : COLORS.health,
        alpha: 150
      }));
    }
  }
}

function spawnBoss() {
  let spawnEdge = floor(random(4));
  let spawnX, spawnY;

  switch (spawnEdge) {
    case 0: spawnX = width / 2; spawnY = -100; break; // Top
    case 1: spawnX = width + 100; spawnY = height / 2; break; // Right
    case 2: spawnX = width / 2; spawnY = height + 100; break; // Bottom
    case 3: spawnX = -100; spawnY = height / 2; break; // Left
  }

  boss = new Enemy(spawnX, spawnY, 'boss', level);
  enemies.push(boss);
}

function spawnEnemy() {
  // Every 3 seconds, try to spawn a squad
  if (floor(gameTime) % 3 === 0 && frameCount % 60 === 0) {
    if (random() < 0.6) { // 60% chance to spawn a squad
      spawnSquad();
      return; // Don't spawn a single enemy if a squad is spawned
    }
  }

  // Determine spawn position outside the screen
  let spawnX, spawnY;
  let edge = floor(random(4));

  switch (edge) {
    case 0: // Top
      spawnX = random(width);
      spawnY = -20;
      break;
    case 1: // Right
      spawnX = width + 20;
      spawnY = random(height);
      break;
    case 2: // Bottom
      spawnX = random(width);
      spawnY = height + 20;
      break;
    case 3: // Left
      spawnX = -20;
      spawnY = random(height);
      break;
  }

  // Determine enemy type based on game time and randomness
  let enemyType = 'basic';
  let enemySize = random(15, 25);
  let enemyHealth = 30 + level * 5;
  let enemySpeed = random(0.8, 1.5);
  let enemyColor = COLORS.enemy1;
  let enemyDamage = 10;

  if (gameTime > 60 && random() < 0.3) { // After 1 minute, 30% chance of fast enemy
    enemyType = 'fast';
    enemySize = random(10, 18);
    enemyHealth = 20 + level * 3;
    enemySpeed = random(2.0, 2.8);
    enemyColor = COLORS.enemy2;
    enemyDamage = 5;
  }

  if (gameTime > 120 && random() < 0.2) { // After 2 minutes, 20% chance of tank enemy
    enemyType = 'tank';
    enemySize = random(30, 40);
    enemyHealth = 80 + level * 10;
    enemySpeed = random(0.5, 0.8);
    enemyColor = COLORS.enemy3;
    enemyDamage = 20;
  }

  if (gameTime > 240 && random() < 0.15) { // After 4 minutes, 15% chance of trail enemy
    enemyType = 'trail';
    enemySize = random(20, 30);
    enemyHealth = 60 + level * 8;
    enemySpeed = random(1.2, 1.8);
    enemyColor = color(255, 50, 255);
    enemyDamage = 15;
  }

  // Create the enemy
  enemies.push(new Enemy(spawnX, spawnY, enemyType, level));
}

function spawnSquad() {
  let squadType = random(['line', 'v_shape', 'circle', 'ranged_support', 'trail_squad']);
  let spawnEdge = floor(random(4));
  let spawnX, spawnY;
  let numEnemies = floor(random(4, 7));

  // Determine starting position for the squad
  switch (spawnEdge) {
    case 0: spawnX = random(width); spawnY = -50; break; // Top
    case 1: spawnX = width + 50; spawnY = random(height); break; // Right
    case 2: spawnX = random(width); spawnY = height + 50; break; // Bottom
    case 3: spawnX = -50; spawnY = random(height); break; // Left
  }

  for (let i = 0; i < numEnemies; i++) {
    let enemyX = spawnX;
    let enemyY = spawnY;
    let enemyType = 'basic';
    let enemySpeed = random(1, 1.5);

    if (squadType === 'line') {
      // Spawn in a line perpendicular to the spawn edge
      if (spawnEdge === 0 || spawnEdge === 2) { // Top or Bottom
        enemyX = spawnX + (i - numEnemies / 2) * 40;
      } else { // Left or Right
        enemyY = spawnY + (i - numEnemies / 2) * 40;
      }
    } else if (squadType === 'v_shape') {
      // Spawn in a V shape
      if (spawnEdge === 0) { // Top
        enemyX = spawnX + (i - numEnemies / 2) * 40;
        enemyY = spawnY + abs(i - numEnemies / 2) * 30;
      } else { // Bottom
        enemyX = spawnX + (i - numEnemies / 2) * 40;
        enemyY = spawnY - abs(i - numEnemies / 2) * 30;
      }
    } else if (squadType === 'circle') {
      // Spawn in a circular pattern
      let angle = TWO_PI * i / numEnemies;
      enemyX = spawnX + cos(angle) * 50;
      enemyY = spawnY + sin(angle) * 50;
    } else if (squadType === 'ranged_support' && gameTime > 150) {
      // After 2.5 minutes, introduce ranged enemies with support
      if (i < 2) { // Two ranged enemies
        enemyType = 'ranged';
      } else {
        enemyType = 'fast';
      }
    } else if (squadType === 'trail_squad' && gameTime > 300) {
      // After 5 minutes, introduce trail enemies in squads
      enemyType = 'trail';
    }

    let enemySize, enemyHealth, enemyColor, enemyDamage;

    switch (enemyType) {
      case 'ranged':
        enemySize = 20;
        enemyHealth = 40 + level * 4;
        enemyColor = color(255, 150, 0);
        enemyDamage = 15;
        break;
      case 'trail':
        enemySize = random(20, 30);
        enemyHealth = 60 + level * 8;
        enemyColor = color(255, 50, 255);
        enemyDamage = 15;
        break;
      default:
        enemySize = random(15, 25);
        enemyHealth = 30 + level * 5;
        enemyColor = COLORS.enemy1;
        enemyDamage = 10;
    }

    enemies.push(new Enemy(enemyX, enemyY, enemyType, level));
  }
}

function killEnemy(index) {
  let e = enemies[index];

  if (e.type === 'boss') {
    boss = null; // Boss is defeated
    generateBossUpgradeOptions();

    // Massive, multi-layered explosion
    // Core explosion
    for (let i = 0; i < 50; i++) {
        let angle = random(TWO_PI);
        let speed = random(5, 15);
        particles.push(new Particle(e.x, e.y, {
            vx: cos(angle) * speed, vy: sin(angle) * speed,
            size: random(10, 20), lifetime: random(60, 100),
            color: color(255, 255, 200), alpha: 255
        }));
    }
    // Shockwave
    particles.push(new Particle(e.x, e.y, {
        vx: 0, vy: 0, size: 10, lifetime: 30,
        color: color(255, 150, 100), expands: true, expansionRate: 20
    }));
    // Debris
    for (let i = 0; i < 80; i++) {
        let angle = random(TWO_PI);
        let speed = random(2, 8);
        particles.push(new Particle(e.x, e.y, {
            vx: cos(angle) * speed, vy: sin(angle) * speed,
            size: random(4, 8), lifetime: random(80, 120),
            color: e.color, alpha: 255, gravity: 0.1
        }));
    }


    // Drop a ton of experience and health
    for (let i = 0; i < 20; i++) {
      pickups.push({
        x: e.x + random(-50, 50), y: e.y + random(-50, 50),
        size: 12, type: 'experience', value: 50
      });
    }
    for (let i = 0; i < 5; i++) {
      pickups.push({
        x: e.x + random(-50, 50), y: e.y + random(-50, 50),
        size: 15, type: 'health', value: 50
      });
    }

    score += 1000;
    kills++;
    enemies.splice(index, 1);
    return; // Avoid normal enemy death logic
  }

  // Create death explosion with more layers
    // Core flash
    for (let i = 0; i < 10; i++) {
        let angle = random(TWO_PI);
        let speed = random(2, 5);
        particles.push(new Particle(e.x, e.y, {
            vx: cos(angle) * speed, vy: sin(angle) * speed,
            size: random(5, 10), lifetime: random(10, 20),
            color: color(255, 255, 200), alpha: 255
        }));
    }
    // Colored particles
    for (let i = 0; i < 15; i++) {
        let angle = random(TWO_PI);
        let speed = random(1, 4);
        particles.push(new Particle(e.x, e.y, {
            vx: cos(angle) * speed, vy: sin(angle) * speed,
            size: random(3, 6), lifetime: random(20, 40),
            color: e.color, alpha: 220, gravity: 0.05
        }));
    }
    // Smoke
    for (let i = 0; i < 5; i++) {
        particles.push(new Particle(e.x, e.y, {
            vx: random(-1, 1), vy: random(-1, 1),
            size: random(10, 15), lifetime: random(30, 50),
            color: color(100, 100, 100), alpha: 150
        }));
    }

  // Drop experience
  let expValue = 5;
  if (e.type === 'fast') expValue = 8;
  if (e.type === 'tank') expValue = 15;

  // 100% chance to drop experience
  pickups.push({
    x: e.x,
    y: e.y,
    size: 10,
    type: 'experience',
    value: expValue
  });

  // 10% chance to drop health
  if (random() < 0.1) {
    pickups.push({
      x: e.x + random(-10, 10),
      y: e.y + random(-10, 10),
      size: 10,
      type: 'health',
      value: 15
    });
  }

  // Increase score
  score += expValue;
  kills++;

  // Remove enemy
  enemies.splice(index, 1);
  playSound('enemyDie', { frequency: 110, wave: 'square', volume: 0.3, duration: 0.1 });
}

function levelUp() {
  // Increase level
  level++;
  playSound('levelUp', { frequency: 660, wave: 'triangle', volume: 0.5, duration: 0.5 });

  // Update experience required for next level
  function levelUp() {
    // Increase level
    level++;
    playSound('levelUp', { frequency: 660, wave: 'triangle', volume: 0.5, duration: 0.5 });

    // Update experience required for next level
    experience = experience - experienceToNextLevel;
    experienceToNextLevel = 100 + level * 50;

    // Generate upgrade options
    generateUpgradeOptions();

    // Enter upgrade state
    gameState = 'upgrade';
  }
  experience = experience - experienceToNextLevel;
  experienceToNextLevel = 100 + level * 50;

  // Generate upgrade options
  generateUpgradeOptions();

  // Enter upgrade state
  gameState = 'upgrade';
}

function generateUpgradeOptions() {
  upgradeOptions = [];

  // Add new items from global upgrades
  if (globalUpgrades.new_items) {
    let level = globalUpgrades.new_items;
    if (level >= 1 && !availableUpgrades.find(u => u.id === 'homing')) {
      availableUpgrades.push({ name: 'Homing Missiles', description: 'Fire missiles that seek enemies.', maxLevel: 3, id: 'homing' });
    }
    if (level >= 2 && !availableUpgrades.find(u => u.id === 'chain_lightning')) {
      availableUpgrades.push({ name: 'Chain Lightning', description: 'Projectiles can chain to nearby enemies.', maxLevel: 3, id: 'chain_lightning' });
    }
    if (level >= 3 && !availableUpgrades.find(u => u.id === 'shield')) {
      availableUpgrades.push({ name: 'Energy Shield', description: 'A shield that blocks enemy projectiles.', maxLevel: 1, id: 'shield' });
    }
  }

  // Get available upgrades (not at max level)
  let available = availableUpgrades.filter(upgrade => {
    if (upgrade.name === 'Speed' && player.speed >= 5) return false;
    if (upgrade.name === 'Damage' && player.damage >= 100) return false;
    if (upgrade.name === 'Fire Rate' && player.fireRate <= 100) return false;
    if (upgrade.name === 'Projectile Size' && player.projectileSize >= 3) return false;
    if (upgrade.name === 'Projectile Speed' && player.projectileSpeed >= 12) return false;
    if (upgrade.name === 'Health' && player.maxHealth >= 300) return false;
    if (upgrade.name === 'Multishot' && player.multishot >= 5) return false;
    if (player.takenUpgrades.includes(upgrade.name) && upgrade.maxLevel === 1) return false;
    return true;
  });

  // Add weapon change option if not all weapons discovered
  if (player.upgradeCount >= 3 && weaponTypes.some(type => type !== player.weapon)) {
    let availableWeapons = weaponTypes.filter(type => type !== player.weapon);
    let newWeapon = random(availableWeapons);

    upgradeOptions.push({
      name: 'Change Weapon',
      description: `Change to ${newWeapon} weapon`,
      effect: () => {
        player.weapon = newWeapon;
        currentWeapon = newWeapon;
      }
    });
  }

  // Add 3 random upgrades
  while (upgradeOptions.length < 3 && available.length > 0) {
    let index = floor(random(available.length));
    let upgrade = available[index];

    // Create the upgrade option
    let option = {
        name: upgrade.name,
        description: upgrade.description,
        effect: () => {}
    };

    switch (upgrade.name) {
        case 'Speed':
            option.effect = () => { player.speed *= 1.15; };
            break;
        case 'Damage':
            option.effect = () => { player.damage *= 1.2; };
            break;
        case 'Fire Rate':
            option.effect = () => { player.fireRate = max(100, player.fireRate * 0.85); };
            break;
        case 'Projectile Size':
            option.effect = () => { player.projectileSize *= 1.25; };
            break;
        case 'Projectile Speed':
            option.effect = () => { player.projectileSpeed *= 1.2; };
            break;
        case 'Health':
            option.effect = () => {
                player.maxHealth *= 1.2;
                player.health += player.maxHealth * 0.2;
            };
            break;
        case 'Multishot':
            option.description = player.multishot === 1 ? 'Fire 2 projectiles at once' : 'Add +1 projectile';
            option.effect = () => { player.multishot += 1; };
            break;
        default:
            option.effect = () => {
                if (!player.takenUpgrades.includes(upgrade.name)) {
                    player.takenUpgrades.push(upgrade.name);
                }
            };
            break;
    }
    upgradeOptions.push(option);


    // Remove from available pool
    available.splice(index, 1);
  }
}

function generateBossUpgradeOptions() {
  upgradeOptions = [
    {
      name: 'Ultimate Power',
      description: 'Damage +50%, Fire Rate +25%',
      effect: () => {
        player.damage *= 1.5;
        player.fireRate = max(100, player.fireRate * 0.75);
      }
    },
    {
      name: 'Aegis Shield',
      description: 'Max Health +100%, become invulnerable for 5s',
      effect: () => {
        player.maxHealth *= 2;
        player.health = player.maxHealth;
        player.invulnerable = 300; // 5 seconds
      }
    },
    {
      name: 'Warp Drive',
      description: 'Speed +50%, Multishot +2',
      effect: () => {
        player.speed *= 1.5;
        player.multishot += 2;
      }
    }
  ];
  gameState = 'upgrade';
}

function selectUpgrade(index) {
  if (index >= 0 && index < upgradeOptions.length) {
    // Apply the upgrade effect
    let selectedUpgrade = upgradeOptions[index];
    selectedUpgrade.effect();
    playSound('upgrade', { frequency: 880, wave: 'sine', volume: 0.4, duration: 0.3 });

    // Add the upgrade to the player's list of taken upgrades
    if (!player.takenUpgrades.includes(selectedUpgrade.name)) {
      player.takenUpgrades.push(selectedUpgrade.name);
    }

    // Increment upgrade count
    player.upgradeCount++;

    // Check for new synergies
    checkForSynergies();

    // Return to playing
    gameState = 'playing';
  }
}

function checkForSynergies() {
  for (const synergy of synergies) {
    if (!activeSynergies.includes(synergy.name)) {
      const hasAllRequired = synergy.required.every(req => player.takenUpgrades.includes(req));
      if (hasAllRequired) {
        activeSynergies.push(synergy.name);
        synergy.effect(player);
        synergyAlerts.push({ name: synergy.name, description: synergy.description, lifetime: 180 });
      }
    }
  }
}

function checkForWeaponEvolution() {
  const weapon = player.weapon;
  if (evolvedWeapons[weapon]) return;

  const weaponLevel = player.getWeaponLevel();
  if (weaponLevel < 5) return;

  const evolution = weaponEvolutions[weapon];
  if (evolution && player.takenUpgrades.includes(evolution.requiredPassive)) {
    evolvedWeapons[weapon] = true;
    player.weapon = evolution.name;
    synergyAlerts.push({
      name: `EVOLVED: ${evolution.name}`,
      description: evolution.description,
      lifetime: 300
    });
  }
}

function gameOver() {
  gameState = 'gameover';
  playSound('gameOver', { frequency: 55, wave: 'sawtooth', volume: 0.8, duration: 2 });

  // Award permanent currency
  let currencyEarned = floor(score / 100);
  permanentCurrency += currencyEarned;

  // Save progress
  saveProgress();
}

function saveProgress() {
  let progress = {
    permanentCurrency: permanentCurrency,
    globalUpgrades: globalUpgrades,
    unlockedShips: unlockedShips
  };
  localStorage.setItem('neonSurvivorProgress', JSON.stringify(progress));
}

function loadProgress() {
  let savedProgress = localStorage.getItem('neonSurvivorProgress');
  if (savedProgress) {
    let progress = JSON.parse(savedProgress);
    permanentCurrency = progress.permanentCurrency || 0;
    globalUpgrades = progress.globalUpgrades || {};
    unlockedShips = progress.unlockedShips || ['Alpha'];
  }
}

function mouseClicked() {
    if (gameState === 'ship_selection') {
        let shipBoxWidth = 200;
        let shipBoxHeight = 250;
        let shipSpacing = 50;
        let totalWidth = ships.length * shipBoxWidth + (ships.length - 1) * shipSpacing;
        let startX = (width - totalWidth) / 2;

        for (let i = 0; i < ships.length; i++) {
            let ship = ships[i];
            let x = startX + i * (shipBoxWidth + shipSpacing);
            let y = height / 2 - shipBoxHeight / 2;

            if (mouseX >= x && mouseX <= x + shipBoxWidth && mouseY >= y && mouseY <= y + shipBoxHeight) {
                if (unlockedShips.includes(ship.name)) {
                    currentShip = ship;
                    gameState = 'playing';
                    resetGame();
                } else if (permanentCurrency >= ship.unlockCost) {
                    permanentCurrency -= ship.unlockCost;
                    unlockedShips.push(ship.name);
                    saveProgress();
                }
                break;
            }
        }
    } else if (gameState === 'mainmenu') {
    let playButton = { x: width / 2 - 100, y: height / 2, w: 200, h: 50 };
    if (mouseX > playButton.x && mouseX < playButton.x + playButton.w && mouseY > playButton.y && mouseY < playButton.y + playButton.h) {
        gameState = 'ship_selection';
    }

    let upgradesButton = { x: width / 2 - 100, y: height / 2 + 70, w: 200, h: 50 };
    if (mouseX > upgradesButton.x && mouseX < upgradesButton.x + upgradesButton.w && mouseY > upgradesButton.y && mouseY < upgradesButton.y + upgradesButton.h) {
      gameState = 'upgrades';
    }
  } else if (gameState === 'upgrades') {
    let backButton = { x: 20, y: 20, w: 100, h: 40 };
    if (mouseX > backButton.x && mouseX < backButton.x + backButton.w && mouseY > backButton.y && mouseY < backButton.y + backButton.h) {
      gameState = 'mainmenu';
    }

    let upgradeY = 150;
    for (let key in globalUpgradeTypes) {
      let upgrade = globalUpgradeTypes[key];
      let level = globalUpgrades[key] || 0;
      let cost = upgrade.cost * (level + 1);
      let purchaseButton = { x: 500, y: upgradeY, w: 200, h: 50 };

      if (mouseX > purchaseButton.x && mouseX < purchaseButton.x + purchaseButton.w && mouseY > purchaseButton.y && mouseY < purchaseButton.y + purchaseButton.h) {
        if (permanentCurrency >= cost && level < upgrade.maxLevel) {
          permanentCurrency -= cost;
          globalUpgrades[key] = (globalUpgrades[key] || 0) + 1;
          saveProgress();
        }
      }
      upgradeY += 100;
    }
  } else if (gameState === 'upgrade') {
    // Check if clicked on an upgrade option
    let boxWidth = 200;
    let boxHeight = 100;
    let boxSpacing = 50;
    let totalWidth = upgradeOptions.length * boxWidth + (upgradeOptions.length - 1) * boxSpacing;
    let startX = (width - totalWidth) / 2;

    for (let i = 0; i < upgradeOptions.length; i++) {
      let x = startX + i * (boxWidth + boxSpacing);
      let y = height / 2 - boxHeight / 2;

      if (mouseX >= x && mouseX <= x + boxWidth && mouseY >= y && mouseY <= y + boxHeight) {
        selectUpgrade(i);
        break;
      }
    }
  } else if (gameState === 'gameover') {
    // Restart game
    setup();
  }
}

function keyPressed() {
  // Number keys 1-3 to select upgrade
  if (gameState === 'upgrade' && keyCode >= 49 && keyCode <= 51) {
    let index = keyCode - 49;
    if (index < upgradeOptions.length) {
      selectUpgrade(index);
    }
  }

  // Space to restart game
  if (gameState === 'gameover' && keyCode === 32) {
    resetGame();
    gameState = 'mainmenu';
  }

  // R to reroll upgrades
  if (gameState === 'upgrade' && keyCode === 82) {
    if (globalUpgrades.reroll_ability && player.rerolls > 0) {
      player.rerolls--;
      generateUpgradeOptions();
    }
  }
}

function drawMainMenu() {
  background(COLORS.background);
  textAlign(CENTER, CENTER);

  // Title
  fill(COLORS.uiHighlight);
  textSize(64);
  text('NEON SURVIVOR', width / 2, height / 4);

  // Play Button
  let playButton = { x: width / 2 - 100, y: height / 2, w: 200, h: 50 };
  fill(COLORS.uiBackground);
  rect(playButton.x, playButton.y, playButton.w, playButton.h, 10);
  fill(COLORS.text);
  textSize(24);
  text('Play', playButton.x + playButton.w / 2, playButton.y + playButton.h / 2);

  // Upgrades Button
  let upgradesButton = { x: width / 2 - 100, y: height / 2 + 70, w: 200, h: 50 };
  fill(COLORS.uiBackground);
  rect(upgradesButton.x, upgradesButton.y, upgradesButton.w, upgradesButton.h, 10);
  fill(COLORS.text);
  textSize(24);
  text('Upgrades', upgradesButton.x + upgradesButton.w / 2, upgradesButton.y + upgradesButton.h / 2);

  // Display permanent currency
  textAlign(RIGHT, TOP);
  fill(COLORS.text);
  textSize(18);
  text(`Crystals: ${permanentCurrency}`, width - 20, 20);
}

function drawShipSelection() {
    background(COLORS.background);
    textAlign(CENTER, CENTER);

    // Title
    fill(COLORS.uiHighlight);
    textSize(48);
    text('Select Your Ship', width / 2, 80);

    // Draw ship options
    let shipBoxWidth = 200;
    let shipBoxHeight = 250;
    let shipSpacing = 50;
    let totalWidth = ships.length * shipBoxWidth + (ships.length - 1) * shipSpacing;
    let startX = (width - totalWidth) / 2;

    for (let i = 0; i < ships.length; i++) {
        let ship = ships[i];
        let x = startX + i * (shipBoxWidth + shipSpacing);
        let y = height / 2 - shipBoxHeight / 2;
        let isUnlocked = unlockedShips.includes(ship.name);
        let isHovered = mouseX >= x && mouseX <= x + shipBoxWidth && mouseY >= y && mouseY <= y + shipBoxHeight;

        // Draw box
        fill(COLORS.uiBackground);
        if (isHovered) {
            stroke(COLORS.uiHighlight);
            strokeWeight(3);
        } else {
            noStroke();
        }
        rect(x, y, shipBoxWidth, shipBoxHeight, 10);

        // Ship name
        noStroke();
        fill(isHovered ? COLORS.uiHighlight : COLORS.text);
        textSize(24);
        text(ship.name, x + shipBoxWidth / 2, y + 30);

        // Ship description
        textSize(14);
        fill(COLORS.text);
        text(ship.description, x + 20, y + 70, shipBoxWidth - 40, 100);

        // Ship trait
        textSize(16);
        fill(COLORS.uiHighlight);
        text(`Trait: ${ship.trait}`, x + shipBoxWidth / 2, y + 150);

        // Unlock status
        if (isUnlocked) {
            fill(0, 255, 0);
            textSize(18);
            text('Unlocked', x + shipBoxWidth / 2, y + shipBoxHeight - 30);
        } else {
            fill(255, 0, 0);
            textSize(18);
            text(`Cost: ${ship.unlockCost}`, x + shipBoxWidth / 2, y + shipBoxHeight - 30);
        }
    }
}

function drawGame() {
  // Draw starfield
  drawStarfield();

  // Draw pickups
  drawPickups();

  // Draw particles
  drawParticles();

  // Draw enemies
  drawEnemies();

  // Draw damage numbers
  drawDamageNumbers();

  // Draw projectiles
  drawProjectiles();

  // Draw enemy projectiles
  drawEnemyProjectiles();

  // Draw player
  drawPlayer();

  // Draw UI
  drawUI();

  // Draw synergy alerts
  drawSynergyAlerts();
}

function updateSynergyAlerts() {
  for (let i = synergyAlerts.length - 1; i >= 0; i--) {
    synergyAlerts[i].lifetime--;
    if (synergyAlerts[i].lifetime <= 0) {
      synergyAlerts.splice(i, 1);
    }
  }
}

function drawSynergyAlerts() {
  let yPos = height / 2;
  for (const alert of synergyAlerts) {
    let alpha = alert.lifetime > 60 ? 255 : map(alert.lifetime, 0, 60, 0, 255);

    push();
    textAlign(CENTER, CENTER);

    // Synergy Name
    textSize(32);
    fill(COLORS.uiHighlight, alpha);
    text(`SYNERGY: ${alert.name}`, width / 2, yPos);

    // Synergy Description
    textSize(18);
    fill(COLORS.text, alpha);
    text(alert.description, width / 2, yPos + 40);

    pop();

    yPos -= 100;
  }
}

function drawStarfield() {
    // Draw nebulas
    for (let nebula of starfield.nebulas) {
        push();
        noStroke();
        noiseSeed(nebula.noiseSeed);
        for (let i = 0; i < 50; i++) {
            let x = nebula.x + (noise(i * 0.1, frameCount * 0.001) - 0.5) * nebula.size;
            let y = nebula.y + (noise(i * 0.1 + 100, frameCount * 0.001) - 0.5) * nebula.size;
            let size = noise(i * 0.2) * 100;
            fill(nebula.color);
            ellipse(x, y, size, size);
        }
        pop();
    }
  // Draw star layers
  function drawLayer(stars, brightness) {
    for (let star of stars) {
        fill(brightness);
        noStroke();
        ellipse(star.x, star.y, star.size, star.size);

        // Move stars based on player movement for parallax
        star.x -= player.speed * star.speed * 0.1 * (keyIsDown(68) ? 1 : (keyIsDown(65) ? -1 : 0));
        star.y -= player.speed * star.speed * 0.1 * (keyIsDown(83) ? 1 : (keyIsDown(87) ? -1 : 0));


        // Wrap stars
        if (star.x < 0) star.x = width;
        if (star.x > width) star.x = 0;
        if (star.y < 0) star.y = height;
        if (star.y > height) star.y = 0;
    }
  }
  drawLayer(starfield.far, 100);
  drawLayer(starfield.mid, 180);
  drawLayer(starfield.near, 255);
}

function drawPlayer() {
  player.draw();
}

function drawEnemyProjectiles() {
  for (let p of enemyProjectiles) {
    fill(p.color);
    noStroke();
    ellipse(p.x, p.y, p.size * 2, p.size * 2);
  }
}

function drawProjectiles() {
  for (let p of projectiles) {
    p.draw();
  }
}

function drawEnemies() {
  for (let e of enemies) {
    e.draw();
  }
}

function drawParticles() {
  for (let p of particles) {
    p.draw();
  }
}

function drawPickups() {
  for (let p of pickups) {
    push();
    translate(p.x, p.y);

    // Float animation
    let floatY = sin(frameCount * 0.1 + p.x) * 3;
    translate(0, floatY);

    // Rotating animation
    rotate(frameCount * 0.02);

    if (p.type === 'experience') {
      // Experience gem
      noStroke();

      // Glow
      fill(COLORS.experience, 100);
      beginShape();
      for (let i = 0; i < 5; i++) {
        let angle = TWO_PI * i / 5 - HALF_PI;
        let r = p.size * 2;
        let x = cos(angle) * r;
        let y = sin(angle) * r;
        vertex(x, y);

        angle += TWO_PI / 10;
        r = p.size;
        x = cos(angle) * r;
        y = sin(angle) * r;
        vertex(x, y);
      }
      endShape(CLOSE);

      // Crystal
      fill(COLORS.experience);
      beginShape();
      for (let i = 0; i < 5; i++) {
        let angle = TWO_PI * i / 5 - HALF_PI;
        let r = p.size * 1.5;
        let x = cos(angle) * r;
        let y = sin(angle) * r;
        vertex(x, y);

        angle += TWO_PI / 10;
        r = p.size * 0.7;
        x = cos(angle) * r;
        y = sin(angle) * r;
        vertex(x, y);
      }
      endShape(CLOSE);

      // Highlight
      fill(255, 150);
      beginShape();
      for (let i = 0; i < 3; i++) {
        let angle = TWO_PI * i / 3;
        let r = p.size * 0.3;
        let x = cos(angle) * r;
        let y = sin(angle) * r;
        vertex(x, y);
      }
      endShape(CLOSE);

    } else if (p.type === 'health') {
      // Health pickup
      // Glow
      noStroke();
      fill(COLORS.health, 100);
      ellipse(0, 0, p.size * 2.5, p.size * 2.5);

      // Cross
      fill(COLORS.health);
      rectMode(CENTER);
      rect(0, 0, p.size * 1.8, p.size * 0.7);
      rect(0, 0, p.size * 0.7, p.size * 1.8);

      // Highlight
      fill(255, 150);
      ellipse(-p.size * 0.3, -p.size * 0.3, p.size * 0.4, p.size * 0.4);
    }

    pop();
  }
}

function drawUI() {
  // Experience bar
  let expBarWidth = width - 40;
  let expBarHeight = 10;
  let expBarX = 20;
  let expBarY = height - 20;

  noStroke();
  fill(COLORS.uiBackground);
  rect(expBarX, expBarY, expBarWidth, expBarHeight, expBarHeight / 2);

  let expPercent = experience / experienceToNextLevel;
  fill(COLORS.experience);
  rect(expBarX, expBarY, expBarWidth * expPercent, expBarHeight, expBarHeight / 2);

  // Level indicator
  textAlign(LEFT, BOTTOM);
  fill(COLORS.text);
  textSize(18);
  text(`Level ${level}`, expBarX, expBarY - 5);

  // Experience text
  textAlign(RIGHT, BOTTOM);
  text(`${experience}/${experienceToNextLevel} XP`, expBarX + expBarWidth, expBarY - 5);

  // Health bar
  let healthBarWidth = 200;
  let healthBarHeight = 20;
  let healthBarX = 20;
  let healthBarY = 20;

  noStroke();
  fill(COLORS.uiBackground);
  rect(healthBarX, healthBarY, healthBarWidth, healthBarHeight, healthBarHeight / 2);

  let healthPercent = player.health / player.maxHealth;
  fill(COLORS.health);
  rect(healthBarX, healthBarY, healthBarWidth * healthPercent, healthBarHeight, healthBarHeight / 2);

  // Health text
  textAlign(CENTER, CENTER);
  fill(COLORS.text);
  textSize(14);
  text(`${ceil(player.health)}/${ceil(player.maxHealth)}`, healthBarX + healthBarWidth / 2, healthBarY + healthBarHeight / 2);

  // Score and time
  textAlign(RIGHT, TOP);
  fill(COLORS.text);
  textSize(18);
  text(`Score: ${score}`, width - 20, 20);
  text(`Time: ${formatTime(gameTime)}`, width - 20, 45);
  text(`Kills: ${kills}`, width - 20, 70);

  // Weapon indicator
  textAlign(LEFT, TOP);
  let weaponName = evolvedWeapons[currentWeapon] ? weaponEvolutions[currentWeapon].name : currentWeapon.charAt(0).toUpperCase() + currentWeapon.slice(1);
  if (evolvedWeapons[currentWeapon]) {
      fill(COLORS.uiHighlight);
      textSize(20);
      text(`EVOLVED: ${weaponName}`, healthBarX + healthBarWidth + 20, healthBarY + 10);
  } else {
      fill(COLORS.text);
      textSize(18);
      text(`Weapon: ${weaponName}`, healthBarX + healthBarWidth + 20, healthBarY);
  }

  // Stats
  let statX = healthBarX + healthBarWidth + 20;
  let statY = healthBarY + 25;
  let statSpacing = 20;

  textSize(14);
  text(`Damage: ${player.damage}`, statX, statY);
  text(`Fire Rate: ${(1000 / player.fireRate).toFixed(1)}/s`, statX, statY + statSpacing);
  text(`Speed: ${player.speed.toFixed(1)}`, statX, statY + statSpacing * 2);

  // Boss health bar
  if (boss) {
    let barWidth = width - 200;
    let barHeight = 20;
    let barX = 100;
    let barY = 20;

    // Boss name
    textAlign(CENTER, BOTTOM);
    textSize(20);
    fill(COLORS.boss);
    text('!! MEGA-MECH MANTIS !!', width / 2, barY - 5);

    // Health bar
    noStroke();
    fill(COLORS.uiBackground);
    rect(barX, barY, barWidth, barHeight);

    let healthPercent = boss.health / boss.maxHealth;
    fill(COLORS.boss);
    rect(barX, barY, barWidth * healthPercent, barHeight);

    // Health text
    textAlign(CENTER, CENTER);
    fill(COLORS.text);
    textSize(14);
    text(`${ceil(boss.health)} / ${ceil(boss.maxHealth)}`, width / 2, barY + barHeight / 2);
  }
}

function formatTime(seconds) {
  let minutes = floor(seconds / 60);
  seconds = floor(seconds % 60);
  return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
}

function drawUpgradeScreen() {
  // Darken background
  fill(0, 0, 0, 150);
  rect(0, 0, width, height);

  // Title
  textAlign(CENTER, CENTER);
  fill(COLORS.text);
  textSize(36);
  text('LEVEL UP!', width / 2, height / 4);
  textSize(18);
  text('Choose an upgrade:', width / 2, height / 4 + 40);

  // Draw upgrade options
  let boxWidth = 200;
  let boxHeight = 100;
  let boxSpacing = 50;
  let totalWidth = upgradeOptions.length * boxWidth + (upgradeOptions.length - 1) * boxSpacing;
  let startX = (width - totalWidth) / 2;

  for (let i = 0; i < upgradeOptions.length; i++) {
    let option = upgradeOptions[i];
    let x = startX + i * (boxWidth + boxSpacing);
    let y = height / 2 - boxHeight / 2;

    // Check if mouse is over this option
    let isHovered = mouseX >= x && mouseX <= x + boxWidth && mouseY >= y && mouseY <= y + boxHeight;

    // Draw box
    fill(COLORS.uiBackground);
    if (isHovered) {
      stroke(COLORS.uiHighlight);
      strokeWeight(3);
    } else {
      noStroke();
    }
    rect(x, y, boxWidth, boxHeight, 10);

    // Draw option text
    textAlign(CENTER, CENTER);
    noStroke();
    fill(isHovered ? COLORS.uiHighlight : COLORS.text);
    textSize(20);
    text(option.name, x + boxWidth / 2, y + 30);

    textSize(14);
    text(option.description, x + boxWidth / 2, y + 60);

    // Draw keybind
    textSize(12);
    fill(COLORS.text, 150);
    text(`Press ${i + 1}`, x + boxWidth / 2, y + boxHeight - 15);
  }

  // Draw reroll count
  if (globalUpgrades.reroll_ability) {
    textAlign(CENTER, BOTTOM);
    fill(COLORS.text);
    textSize(18);
    text(`Rerolls available: ${player.rerolls} (Press R)`, width / 2, height - 20);
  }
}

function drawGameOverScreen() {
  // Darken background
  fill(0, 0, 0, 200);
  rect(0, 0, width, height);

  // Game over text
  textAlign(CENTER, CENTER);
  fill(COLORS.text);
  textSize(48);
  text('GAME OVER', width / 2, height / 3);

  // Stats
  textSize(24);
  text(`Time Survived: ${formatTime(gameTime)}`, width / 2, height / 2);
  text(`Score: ${score}`, width / 2, height / 2 + 40);
  text(`Enemies Killed: ${kills}`, width / 2, height / 2 + 80);
  text(`Level Reached: ${level}`, width / 2, height / 2 + 120);

  // Restart prompt
  textSize(18);
  fill(COLORS.uiHighlight);
  text('Press SPACE to restart', width / 2, height * 3 / 4);
}

function drawUpgradeStore() {
  background(COLORS.background);
  textAlign(CENTER, CENTER);

  // Title
  fill(COLORS.uiHighlight);
  textSize(48);
  text('Global Upgrades', width / 2, 80);

  // Display permanent currency
  textAlign(RIGHT, TOP);
  fill(COLORS.text);
  textSize(18);
  text(`Crystals: ${permanentCurrency}`, width - 20, 20);

  // Back Button
  let backButton = { x: 20, y: 20, w: 100, h: 40 };
  fill(COLORS.uiBackground);
  rect(backButton.x, backButton.y, backButton.w, backButton.h, 10);
  fill(COLORS.text);
  textSize(18);
  text('Back', backButton.x + backButton.w / 2, backButton.y + backButton.h / 2);

  // Draw upgrade options
  let upgradeY = 150;
  for (let key in globalUpgradeTypes) {
    let upgrade = globalUpgradeTypes[key];
    let level = globalUpgrades[key] || 0;

    textAlign(LEFT, TOP);
    fill(COLORS.text);
    textSize(22);
    text(upgrade.name, 100, upgradeY);

    textSize(16);
    text(upgrade.description, 100, upgradeY + 30);

    let cost = upgrade.cost * (level + 1);
    let buttonText = level >= upgrade.maxLevel ? 'Max Level' : `Cost: ${cost}`;
    let purchaseButton = { x: 500, y: upgradeY, w: 200, h: 50 };

    fill(COLORS.uiBackground);
    rect(purchaseButton.x, purchaseButton.y, purchaseButton.w, purchaseButton.h, 10);

    fill(COLORS.text);
    textSize(18);
    text(buttonText, purchaseButton.x + purchaseButton.w / 2, purchaseButton.y + purchaseButton.h / 2);

    upgradeY += 100;
  }
}

function resetGame() {
  player = new Player(width / 2, height / 2);
  enemies = [];
  projectiles = [];
  enemyProjectiles = [];
  particles = [];
  pickups = [];
  damageNumbers = [];
  gameTime = 0;
  score = 0;
  level = 1;
  experience = 0;
  experienceToNextLevel = 100;
  upgradeOptions = [];
  activeSynergies = [];
  synergyAlerts = [];
  evolvedWeapons = {};
  currentWeapon = 'laser';
  boss = null;
}

const RANGED_ENEMY_COOLDOWN = 2000;
const BOSS_ATTACK_COOLDOWN = 2000;
const TRAIL_PARTICLE_LIFETIME = 180;

class Player {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.size = 24;
    this.speed = 3;
    this.health = 100;
    this.maxHealth = 100;
    this.damage = 20;
    this.fireRate = 300; // milliseconds between shots
    this.lastFired = 0;
    this.rerolls = 0;

    // Apply ship trait
    if (currentShip.trait === '+10% speed') {
        this.speed *= 1.1;
    }
    if (currentShip.trait === 'Starts with an extra projectile') {
        this.multishot = 2;
    }


    // Apply global upgrades
    if (globalUpgrades.bonus_stats) {
      let level = globalUpgrades.bonus_stats;
      this.health += level * 10;
      this.maxHealth += level * 10;
      this.damage += level * 2;
    }
    if (globalUpgrades.reroll_ability) {
      this.rerolls = globalUpgrades.reroll_ability;
    }
    this.projectileSize = 1;
    this.projectileSpeed = 5;
    if (currentShip.trait !== 'Starts with an extra projectile') {
        this.multishot = 1;
    }
    this.upgradeCount = 0;
    this.invulnerable = 0; // invulnerability timer
    this.angle = 0; // facing angle
    this.weapon = currentShip.weapon;
    this.takenUpgrades = [];
    this.synergies = {};
    this.weaponLevels = {
        laser: 0,
        plasma: 0,
        wave: 0
    };
  }

  getWeaponLevel() {
    return this.weaponLevels[this.weapon] || 0;
  }

  update() {
    // Handle player movement
    let dx = 0;
    let dy = 0;

    if (keyIsDown(87) || keyIsDown(UP_ARROW)) dy -= 1; // W or Up arrow
    if (keyIsDown(83) || keyIsDown(DOWN_ARROW)) dy += 1; // S or Down arrow
    if (keyIsDown(65) || keyIsDown(LEFT_ARROW)) dx -= 1; // A or Left arrow
    if (keyIsDown(68) || keyIsDown(RIGHT_ARROW)) dx += 1; // D or Right arrow

    // Normalize diagonal movement
    if (dx !== 0 && dy !== 0) {
      dx *= 0.7071; // 1/sqrt(2)
      dy *= 0.7071;
    }

    this.x += dx * this.speed;
    this.y += dy * this.speed;

    // Keep player in bounds
    this.x = constrain(this.x, this.size, width - this.size);
    this.y = constrain(this.y, this.size, height - this.size);

    // Update player angle to face mouse
    if (mouseX !== 0 && mouseY !== 0) {
      this.angle = atan2(mouseY - this.y, mouseX - this.x);
    }

    // Auto fire
    if (millis() - this.lastFired > this.fireRate) {
      this.fire();
      this.lastFired = millis();
    }

    // Decrease invulnerability timer
    if (this.invulnerable > 0) {
      this.invulnerable--;
    }
  }

  fire() {
    let baseAngle = atan2(mouseY - this.y, mouseX - this.x);

    if (this.weapon === 'laser') playSound('shootLaser', { frequency: 440, wave: 'sawtooth', volume: 0.3, duration: 0.1 });
    if (this.weapon === 'plasma') playSound('shootPlasma', { frequency: 330, wave: 'square', volume: 0.4, duration: 0.15 });
    if (this.weapon === 'wave') playSound('shootWave', { frequency: 220, wave: 'sine', volume: 0.3, duration: 0.2 });


    if (this.weapon === 'wave' || this.weapon === 'Resonance Blaster') {
      let angleSpread = PI / 2; // Wide 90-degree arc
      let numProjectiles = 5 + this.multishot * 2; // More projectiles for a denser wave
      for (let i = 0; i < numProjectiles; i++) {
        let angle = baseAngle - angleSpread / 2 + (angleSpread * i / (numProjectiles - 1));
        projectiles.push(new Projectile(this.x, this.y, angle, this));
      }
    } else {
      // Calculate spread based on multishot for laser and plasma
      let angleSpread = 0;
      if (this.multishot > 1) {
        angleSpread = PI / 8;
      }

      for (let i = 0; i < this.multishot; i++) {
        let angle = baseAngle;

        // If we have multiple shots, adjust the angle
        if (this.multishot > 1) {
          angle = baseAngle - angleSpread/2 + (angleSpread * i / (this.multishot - 1));
        }

        projectiles.push(new Projectile(this.x, this.y, angle, this));

        // Add muzzle flash particle
        let flashColor;
        switch (this.weapon) {
          case 'laser': flashColor = COLORS.projectileLaser; break;
          case 'plasma': flashColor = COLORS.projectilePlasma; break;
          case 'wave': flashColor = COLORS.projectileWave; break;
          case 'Phasor': flashColor = color(255, 100, 100); break;
          case 'Singularity Cannon': flashColor = color(150, 50, 255); break;
          case 'Resonance Blaster': flashColor = color(100, 255, 255); break;
        }

        for (let j = 0; j < 3; j++) {
          particles.push(new Particle(this.x + cos(angle) * this.size, this.y + sin(angle) * this.size, {
            vx: cos(angle) * random(1, 3) + random(-1, 1),
            vy: sin(angle) * random(1, 3) + random(-1, 1),
            size: random(2, 5),
            lifetime: random(10, 20),
            color: flashColor,
            alpha: 255
          }));
        }
      }
    }
  }

  draw() {
    push();
    translate(this.x, this.y);
    rotate(this.angle);

    // Draw player shadow/glow
    fill(COLORS.playerShadow);
    noStroke();

    // Pulse effect for shield when invulnerable
    if (this.invulnerable > 0) {
        let pulseSize = 1.2 + sin(frameCount * 0.2) * 0.1;
        ellipse(0, 0, this.size * 2 * pulseSize, this.size * 2 * pulseSize);
    }

    // Engine glow
    let engineGlow = 1 + sin(frameCount * 0.5) * 0.2;
    fill(255, 100, 0, 150);
    beginShape();
    vertex(-this.size * 0.6, 0);
    vertex(-this.size * 0.8, this.size * 0.3 * engineGlow);
    vertex(-this.size * 1.2, 0);
    vertex(-this.size * 0.8, -this.size * 0.3 * engineGlow);
    endShape(CLOSE);


    // Ship body
    fill(100, 150, 255); // Main body color
    stroke(200, 220, 255); // Light outline
    strokeWeight(2);

    beginShape();
    vertex(this.size, 0); // Nose
    vertex(-this.size * 0.8, this.size * 0.6); // Right wing
    vertex(-this.size * 0.6, 0); // Back center
    vertex(-this.size * 0.8, -this.size * 0.6); // Left wing
    endShape(CLOSE);

    // Cockpit
    fill(20, 20, 50, 200); // Dark, semi-transparent
    stroke(100, 150, 255, 150);
    strokeWeight(1);
    ellipse(this.size * 0.4, 0, this.size * 0.8, this.size * 0.6);

    // Weapon ports
    let firing = (millis() - this.lastFired) < 100;
    if (firing) {
        fill(255, 200, 0); // Yellow glow when firing
        noStroke();
        ellipse(this.size * 0.7, this.size * 0.4, this.size * 0.2, this.size * 0.2);
        ellipse(this.size * 0.7, -this.size * 0.4, this.size * 0.2, this.size * 0.2);
    } else {
        fill(100, 120, 180); // Default color
        stroke(150, 180, 220);
        strokeWeight(1);
        ellipse(this.size * 0.7, this.size * 0.4, this.size * 0.15, this.size * 0.15);
        ellipse(this.size * 0.7, -this.size * 0.4, this.size * 0.15, this.size * 0.15);
    }

    pop();
  }
}

class Projectile {
  constructor(x, y, angle, owner) {
    this.x = x;
    this.y = y;
    this.angle = angle;
    this.owner = owner;
    this.type = owner.weapon;
    this.projectileSize = owner.projectileSize;
    this.damage = owner.damage;
    this.speed = owner.projectileSpeed;

    if (this.type === 'wave') {
        this.speed *= 0.8;
        this.damage *= 0.7;
        this.lifetime = 45;
        this.size = 8 * this.projectileSize;
    } else if (this.type === 'Phasor') {
        this.speed *= 1.5;
        this.damage *= 0.5;
        this.lifetime = 20;
        this.size = 20 * this.projectileSize;
        this.pierce = Infinity;
    } else if (this.type === 'Singularity Cannon') {
        this.speed *= 0.5;
        this.lifetime = 300;
        this.size = 15 * this.projectileSize;
    } else if (this.type === 'Resonance Blaster') {
        this.speed *= 0.7;
        this.damage *= 0.8;
        this.lifetime = 240;
        this.size = 10 * this.projectileSize;
        this.bounces = 3;
    } else {
        this.lifetime = 180; // frames
        this.size = 6 * this.projectileSize;
    }

    if (this.type === 'laser') {
        this.pierce = 3;
    }

    this.vx = cos(angle) * this.speed;
    this.vy = sin(angle) * this.speed;
  }

  update() {
    // Move projectile
    this.x += this.vx;
    this.y += this.vy;

    if (this.type === 'Resonance Blaster') {
        if (this.x < 0 || this.x > width) {
            this.vx *= -1;
            this.bounces--;
        }
        if (this.y < 0 || this.y > height) {
            this.vy *= -1;
            this.bounces--;
        }
        if (this.bounces < 0) {
            this.lifetime = 0;
        }
    }

    // Create trail particles
    if (frameCount % 2 === 0) {
      let trailColor;
      switch (this.type) {
        case 'laser': trailColor = COLORS.projectileLaser; break;
        case 'plasma': trailColor = COLORS.projectilePlasma; break;
        case 'wave': trailColor = COLORS.projectileWave; break;
        case 'Phasor': trailColor = color(255, 100, 100); break;
        case 'Singularity Cannon': trailColor = color(150, 50, 255); break;
        case 'Resonance Blaster': trailColor = color(100, 255, 255); break;
      }

      particles.push(new Particle(this.x, this.y, {
        vx: random(-0.5, 0.5),
        vy: random(-0.5, 0.5),
        size: random(1, 3) * this.projectileSize,
        lifetime: random(10, 20),
        color: trailColor,
        alpha: 150
      }));
    }
    this.lifetime--;
  }

  draw() {
    push();
    translate(this.x, this.y);
    rotate(this.angle);

    // Different projectile types
    if (this.type === 'laser') {
        // Outer glow
        stroke(0, 255, 200, 100);
        strokeWeight(this.size * 1.5);
        line(0, 0, -this.size * 4, 0);
        // Inner core
        stroke(255);
        strokeWeight(this.size * 0.5);
        line(0, 0, -this.size * 4, 0);

    } else if (this.type === 'plasma') {
        noStroke();
        // Swirling energy
        let pulse = sin(frameCount * 0.4) * this.size * 0.2;
        for (let i = 5; i > 0; i--) {
            let alpha = 255 - (i * 50);
            let d = this.size * (1 + i * 0.2) + pulse;
            fill(255, 220, 100, alpha);
            ellipse(0, 0, d, d);
        }
        // Crackling particles
        for(let i = 0; i < 2; i++) {
            let angle = random(TWO_PI);
            let r = this.size * 0.8;
            let x = cos(angle) * r;
            let y = sin(angle) * r;
            fill(255, 255, 200, random(150, 255));
            ellipse(x, y, this.size * 0.3, this.size * 0.3);
        }

    } else if (this.type === 'wave') {
        noFill();
        stroke(200, 100, 255, 220);
        strokeWeight(this.size * 0.6);
        let arcSize = this.size * 2.5;
        arc(0, 0, arcSize, arcSize, -PI/3, PI/3);
        stroke(255, 200, 255, 150);
        strokeWeight(this.size * 0.3);
        arc(0, 0, arcSize * 1.2, arcSize * 1.2, -PI/3, PI/3);

    } else if (this.type === 'Phasor') {
        // Wide, continuous beam
        stroke(255, 80, 80, 180);
        strokeWeight(this.size * 1.2);
        line(0, 0, -this.size * 6, 0);
        stroke(255, 150, 150, 220);
        strokeWeight(this.size * 0.6);
        line(0, 0, -this.size * 6, 0);

    } else if (this.type === 'Singularity Cannon') {
        noStroke();
        // Gravitational lens effect
        for(let i = 0; i < 10; i++) {
            let angle = random(TWO_PI);
            let r = random(this.size, this.size * 2);
            let x = cos(angle) * r;
            let y = sin(angle) * r;
            fill(random(100, 200), 50, 255, 50);
            ellipse(x, y, this.size * 0.5, this.size * 0.5);
        }
        // Black hole core
        fill(0);
        ellipse(0, 0, this.size, this.size);

    } else if (this.type === 'Resonance Blaster') {
        noFill();
        let pulse = sin(frameCount * 0.3) * 0.1 + 1.0;
        // Outer ring
        stroke(100, 255, 255, 255);
        strokeWeight(this.size * 0.2 * pulse);
        ellipse(0, 0, this.size * 2.5, this.size * 2.5);
        // Inner ring
        stroke(200, 255, 255, 150);
        strokeWeight(this.size * 0.4);
        ellipse(0, 0, this.size * 1.8 * pulse, this.size * 1.8 * pulse);
    }

    pop();
  }

  isOffscreen() {
    return (this.x < 0 || this.x > width || this.y < 0 || this.y > height || this.lifetime <= 0);
  }
}

class Enemy {
  constructor(x, y, type, level) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.pulseTime = random(TWO_PI);
    this.lastFired = 0;
    this.angle = 0;

    // Properties based on type
    switch (type) {
      case 'fast':
        this.size = random(10, 18);
        this.health = 20 + level * 3;
        this.speed = random(2.0, 2.8);
        this.color = COLORS.enemy2;
        this.damage = 5;
        break;
      case 'tank':
        this.size = random(30, 40);
        this.health = 80 + level * 10;
        this.speed = random(0.5, 0.8);
        this.color = COLORS.enemy3;
        this.damage = 20;
        break;
      case 'trail':
        this.size = random(20, 30);
        this.health = 60 + level * 8;
        this.speed = random(1.2, 1.8);
        this.color = color(255, 50, 255);
        this.damage = 15;
        break;
      case 'ranged':
        this.size = 20;
        this.health = 40 + level * 4;
        this.speed = random(1, 1.5);
        this.color = color(255, 150, 0);
        this.damage = 15;
        this.attackCooldown = RANGED_ENEMY_COOLDOWN;
        break;
      case 'boss':
        this.size = 80;
        this.health = 2000 + level * 500;
        this.speed = 0.8;
        this.color = COLORS.boss;
        this.damage = 50;
        this.attackCooldown = BOSS_ATTACK_COOLDOWN;
        this.attackPattern = 'circle';
        this.lastFired = 0;
        break;
      default: // basic
        this.size = random(15, 25);
        this.health = 30 + level * 5;
        this.speed = random(0.8, 1.5);
        this.color = COLORS.enemy1;
        this.damage = 10;
        break;
    }
    this.maxHealth = this.health;
    this.speed *= (1 + level * 0.05);
  }

  update(player) {
    // Boss AI
    if (this.type === 'boss') {
      let distanceToPlayer = dist(this.x, this.y, player.x, player.y);
      if (distanceToPlayer > 300) {
        let angle = atan2(player.y - this.y, player.x - this.x);
        this.x += cos(angle) * this.speed;
        this.y += sin(angle) * this.speed;
        this.angle = angle;
      } else {
        // Strafe
        let angle = atan2(player.y - this.y, player.x - this.x) + HALF_PI;
        this.x += cos(angle) * this.speed * 0.5;
        this.y += sin(angle) * this.speed * 0.5;
        this.angle = atan2(player.y - this.y, player.x - this.x);
      }
    } else {
        // Move enemy toward player
        let angle = atan2(player.y - this.y, player.x - this.x);
        this.x += cos(angle) * this.speed;
        this.y += sin(angle) * this.speed;
        this.angle = angle;
    }


    // Ranged enemies fire projectiles
    if (this.type === 'ranged' && millis() - this.lastFired > this.attackCooldown) {
      fireEnemyProjectile(this);
      this.lastFired = millis();
    } else if (this.type === 'boss' && millis() - this.lastFired > this.attackCooldown) {
      fireBossProjectile(this);
      this.lastFired = millis();
    }

    // Leave trail
    if (this.type === 'trail' && frameCount % 5 === 0) {
        particles.push(new Particle(this.x, this.y, {
            vx: 0,
            vy: 0,
            size: this.size * 1.5,
            lifetime: TRAIL_PARTICLE_LIFETIME,
            color: this.color,
            alpha: 150,
            damaging: true,
            damage: 5
        }));
    } else if (frameCount % 10 === 0) {
        particles.push(new Particle(this.x, this.y, {
            vx: random(-0.5, 0.5),
            vy: random(-0.5, 0.5),
            size: random(2, 4),
            lifetime: random(10, 20),
            color: this.color,
            alpha: 100
        }));
    }
  }

  draw() {
    push();
    translate(this.x, this.y);
    rotate(this.angle);

    // Draw health bar
    let healthPercent = this.health / this.maxHealth;

    if (healthPercent < 1) {
        push();
        translate(0, -this.size - 10);
        noStroke();
        fill(100, 100, 100, 150);
        rect(-this.size, -2, this.size * 2, 4);
        fill(255, 0, 50, 200);
        rect(-this.size, -2, this.size * 2 * healthPercent, 4);
        pop();
    }

    // Different enemy types
    if (this.type === 'basic') {
        noStroke();
        this.pulseTime += 0.05;
        let pulse = 1 + sin(this.pulseTime) * 0.1;

        fill(this.color, 50);
        ellipse(0, 0, this.size * 2.5 * pulse, this.size * 2.5 * pulse);

        // Body
        fill(this.color);
        beginShape();
        vertex(this.size, 0);
        vertex(-this.size * 0.5, this.size * 0.8);
        vertex(-this.size, 0);
        vertex(-this.size * 0.5, -this.size * 0.8);
        endShape(CLOSE);

        // Eye
        fill(255, 255, 0);
        ellipse(this.size * 0.2, 0, this.size * 0.5, this.size * 0.5);
        fill(0);
        ellipse(this.size * 0.2, 0, this.size * 0.2, this.size * 0.2);

    } else if (this.type === 'fast') {
        noStroke();

        // Motion trail
        fill(this.color, 30);
        for(let i = 0; i < 5; i++) {
            let trailSize = this.size * (1 - i * 0.1);
            ellipse(-this.size * i * 0.4, 0, trailSize * 2, trailSize * 0.5);
        }

        // Fins
        fill(this.color, 150);
        beginShape();
        vertex(0, -this.size * 0.5);
        vertex(-this.size * 1.5, 0);
        vertex(0, this.size * 0.5);
        endShape();

        // Body
        fill(this.color);
        beginShape();
        vertex(this.size, 0);
        vertex(-this.size * 0.8, this.size * 0.4);
        vertex(-this.size, 0);
        vertex(-this.size * 0.8, -this.size * 0.4);
        endShape(CLOSE);

    } else if (this.type === 'tank') {
        this.pulseTime += 0.03;
        let pulse = 1 + sin(this.pulseTime) * 0.05;

        noStroke();
        fill(this.color, 40);
        ellipse(0, 0, this.size * 2.2 * pulse, this.size * 2.2 * pulse);

        // Armor plates
        fill(this.color, 180);
        rect(-this.size * 0.8, -this.size * 0.8, this.size * 1.6, this.size * 1.6, 4);
        fill(this.color, 220);
        rect(-this.size * 0.6, -this.size * 0.6, this.size * 1.2, this.size * 1.2, 4);

        // Core
        fill(255, 100, 0);
        ellipse(0, 0, this.size * 0.8, this.size * 0.8);
        fill(255, 200, 0);
        ellipse(0, 0, this.size * 0.5 * pulse, this.size * 0.5 * pulse);

    } else if (this.type === 'boss') {
        this.pulseTime += 0.02;
        let pulse = 1 + sin(this.pulseTime) * 0.05;

        noStroke();
        fill(this.color, 30);
        ellipse(0, 0, this.size * 2.5 * pulse, this.size * 2.5 * pulse);

        // Rotating weapon systems
        push();
        rotate(this.pulseTime * 0.8);
        fill(this.color, 200);
        for(let i = 0; i < 4; i++) {
            rect(-this.size, -this.size * 0.15, this.size * 2, this.size * 0.3, 5);
            rotate(HALF_PI);
        }
        pop();

        // Main body
        fill(COLORS.background);
        stroke(this.color);
        strokeWeight(5);
        ellipse(0, 0, this.size * 1.4, this.size * 1.4);

        // Central eye
        fill(this.color);
        noStroke();
        ellipse(0, 0, this.size * 0.7, this.size * 0.7);
        fill(255, 255, 0);
        ellipse(0, 0, this.size * 0.4 * pulse, this.size * 0.4 * pulse);
        fill(0);
        ellipse(0, 0, this.size * 0.1, this.size * 0.1);
    }

    pop();
  }
}

class Particle {
  constructor(x, y, options) {
    this.x = x;
    this.y = y;
    this.vx = options.vx || random(-1, 1);
    this.vy = options.vy || random(-1, 1);
    this.size = options.size || random(2, 5);
    this.lifetime = options.lifetime || random(10, 30);
    this.color = options.color || color(255);
    this.alpha = options.alpha || 255;
    this.damaging = options.damaging || false;
    this.damage = options.damage || 0;
    this.pulls = options.pulls || false;
    this.gravity = options.gravity || 0;
    this.expands = options.expands || false;
    this.expansionRate = options.expansionRate || 0;
    this.initialSize = this.size;
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += this.gravity;
    this.alpha = this.alpha * (this.lifetime / (this.lifetime + 1));
    this.lifetime--;

    if (this.expands) {
        this.size += this.expansionRate;
        this.alpha = 255 * (this.lifetime / 30);
    }
  }

  draw() {
    noStroke();
    if(this.expands) {
        let c = this.color;
        c.setAlpha(this.alpha);
        stroke(c);
        strokeWeight(this.size * 0.1);
        noFill();
    } else {
        fill(this.color, this.alpha);
    }
    ellipse(this.x, this.y, this.size, this.size);
  }

  isDead() {
    return this.lifetime <= 0;
  }
}
    </script>
</body>
</html>
