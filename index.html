<!DOCTYPE html>
<html lang="en">
<body>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #111;
            font-family: Arial, sans-serif;
            color: #fff;
        }
        
        #game-container {
            position: relative;
        }
        
        canvas {
            display: block;
            margin: 0 auto;
            border: 2px solid #333;
        }
        
        .instructions {
            max-width: 800px;
            margin: 20px auto;
            padding: 15px;
            background-color: rgba(0, 20, 40, 0.8);
            border-radius: 8px;
        }
        
        h1 {
            text-align: center;
            color: #00aaff;
        }
        
        h2 {
            color: #00ccff;
        }
    </style>
    <div id="game-container">
        <h1>NEON SURVIVOR</h1>
        
        <div id="canvas-container"></div>
        
        <div class="instructions">
            <h2>How to Play</h2>
            <p><strong>Movement:</strong> WASD or Arrow Keys</p>
            <p><strong>Aim:</strong> Mouse pointer</p>
            <p><strong>Shooting:</strong> Automatic</p>
            <p><strong>Upgrade Selection:</strong> Mouse click or number keys (1-3)</p>
            <p><strong>Restart (Game Over):</strong> Space bar</p>
            
            <h2>Game Mechanics</h2>
            <p>Survive as long as possible by defeating enemies. Collect experience gems to level up and choose upgrades.</p>
            <p>Blue gems are experience, red crosses are health pickups.</p>
            <p>There are three types of enemies:
                <br>- Red triangles (basic)
                <br>- Purple arrows (fast)
                <br>- Orange circles (tank)
            </p>
            <p>There are three weapon types you can unlock:
                <br>- Laser (green)
                <br>- Plasma (yellow)
                <br>- Wave (purple)
            </p>
        </div>
    </div>
    
    <!-- Load P5.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    
    <!-- Load Howler.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>

    <!-- Load game script -->
    <script>
        // Neon Survivor - A Vampire Survivors style game with futuristic theme
// All assets created programmatically with P5.js

const ships = [
    {
        name: 'Default',
        description: 'A standard ship with no special modifications.',
        startingWeapon: 'laser',
        trait: null,
        unlockCondition: () => true,
    },
    {
        name: 'Juggernaut',
        description: 'A heavy ship with increased health and damage, but reduced speed.',
        startingWeapon: 'plasma',
        trait: {
            health: 1.2,
            damage: 1.1,
            speed: 0.9,
        },
        unlockCondition: (stats) => stats.totalKills >= 100,
    },
    {
        name: 'Interceptor',
        description: 'A fast and agile ship with a high-speed cannon.',
        startingWeapon: 'laser',
        trait: {
            speed: 1.2,
            fireRate: 0.9,
        },
        unlockCondition: (stats) => stats.longestTime >= 300,
    },
];

const weaponEvolutions = {
    laser: {
        name: 'Phasor',
        description: 'Fires a continuous, wide beam of energy that pierces through all enemies.',
        requiredPassive: 'High-Energy Capacitor',
    },
    plasma: {
        name: 'Singularity Cannon',
        description: 'Creates a black hole on impact, pulling in and damaging nearby enemies.',
        requiredPassive: 'Graviton Emitter',
    },
    wave: {
        name: 'Resonance Blaster',
        description: 'Fires expanding energy rings that bounce off the edges of the screen.',
        requiredPassive: 'Sonic Amplifier',
    }
};

let player;
let enemies = [];
let projectiles = [];
let enemyProjectiles = [];
let particles = [];
let pickups = [];
let damageNumbers = [];
let gameTime = 0;
let score = 0;
let level = 1;
let experience = 0;
let experienceToNextLevel = 100;
let gameState = 'shipSelection'; // 'shipSelection', 'playing', 'upgrade', 'gameover'
let upgradeOptions = [];
let availableUpgrades = [
  { name: 'Speed', description: 'Increase movement speed', maxLevel: 5, id: 'speed' },
  { name: 'Damage', description: 'Increase projectile damage', maxLevel: 5, id: 'damage' },
  { name: 'Fire Rate', description: 'Increase firing speed', maxLevel: 5, id: 'fireRate' },
  { name: 'Projectile Size', description: 'Increase projectile size', maxLevel: 5, id: 'projectileSize' },
  { name: 'Projectile Speed', description: 'Increase projectile velocity', maxLevel: 5, id: 'projectileSpeed' },
  { name: 'Health', description: 'Increase max health', maxLevel: 5, id: 'health' },
  { name: 'Multishot', description: 'Fire additional projectiles', maxLevel: 3, id: 'multishot' },
  { name: 'High-Energy Capacitor', description: 'Required for Phasor evolution', maxLevel: 1, id: 'highEnergyCapacitor' },
  { name: 'Graviton Emitter', description: 'Required for Singularity Cannon evolution', maxLevel: 1, id: 'gravitonEmitter' },
  { name: 'Sonic Amplifier', description: 'Required for Resonance Blaster evolution', maxLevel: 1, id: 'sonicAmplifier' }
];
let activeSynergies = [];
let synergyAlerts = [];
const synergies = [
  {
    name: 'Supernova',
    description: 'Projectiles create a damaging explosion on impact',
    required: ['Multishot', 'Projectile Size'],
    effect: (player) => {
      player.synergies.supernova = true;
    }
  }
];
let weaponTypes = ['laser', 'plasma', 'wave'];
let evolvedWeapons = {};
let currentWeapon = 'laser';
let gameFont;
let starfield = [];
let screenShake = 0;
let kills = 0;
let boss = null;
let sounds;
let gameStats = {
    totalKills: 0,
    longestTime: 0,
};

// Color palette
const COLORS = {
  background: '#0a0a1a',
  player: '#00ccff',
  playerShadow: '#0066ff',
  enemy1: '#ff0066',
  enemy2: '#cc00ff',
  enemy3: '#ff9900',
  boss: '#ff6600', // A fiery orange for the boss
  projectileLaser: '#00ffcc',
  projectilePlasma: '#ffcc00',
  projectileWave: '#cc66ff',
  experience: '#00ff99',
  health: '#ff3366',
  text: '#ffffff',
  uiBackground: 'rgba(0, 20, 40, 0.8)',
  uiHighlight: '#00aaff'
};

function preload() {
  // Load sounds
  sounds = {
    shootLaser: new Howl({ src: ['https://assets.codepen.io/210284/laser-shoot.wav'], volume: 0.3 }),
    shootPlasma: new Howl({ src: ['https://assets.codepen.io/210284/plasma-shoot.wav'], volume: 0.4 }),
    shootWave: new Howl({ src: ['https://assets.codepen.io/210284/wave-shoot.wav'], volume: 0.3 }),
    enemyHit: new Howl({ src: ['https://assets.codepen.io/210284/enemy-hit.wav'], volume: 0.2 }),
    enemyDie: new Howl({ src: ['https://assets.codepen.io/210284/enemy-die.wav'], volume: 0.3 }),
    playerHit: new Howl({ src: ['https://assets.codepen.io/210284/player-hit.wav'], volume: 0.5 }),
    pickupExp: new Howl({ src: ['https://assets.codepen.io/210284/pickup-exp.wav'], volume: 0.2, rate: 1.5 }),
    pickupHealth: new Howl({ src: ['https://assets.codepen.io/210284/pickup-health.wav'], volume: 0.4 }),
    levelUp: new Howl({ src: ['https://assets.codepen.io/210284/level-up.wav'], volume: 0.5 }),
    upgrade: new Howl({ src: ['https://assets.codepen.io/210284/upgrade.wav'], volume: 0.4 }),
    gameOver: new Howl({ src: ['https://assets.codepen.io/210284/game-over.wav'], volume: 0.5 })
  };
}

function setup() {
  let canvas = createCanvas(800, 600);
  canvas.parent('canvas-container');
  strokeJoin(ROUND);
  strokeCap(ROUND);

  // Convert color strings in COLORS to p5.Color objects
  for (let key in COLORS) {
    COLORS[key] = color(COLORS[key]);
  }

  // Setup starfield
  for (let i = 0; i < 100; i++) {
    starfield.push({
      x: random(width),
      y: random(height),
      size: random(1, 3),
      speed: random(0.2, 1),
      brightness: random(100, 255)
    });
  }

  // Initialize player
  player = new Player(width / 2, height / 2);

  // Start the game
  gameState = 'playing';
}

function DamageNumber(x, y, amount) {
  this.x = x;
  this.y = y;
  this.amount = amount;
  this.lifetime = 60; // 1 second
  this.alpha = 255;
}

function draw() {
  background(COLORS.background);

  if (gameState === 'playing') {
    updateGame();
    drawGame();
  } else if (gameState === 'upgrade') {
    drawGame(); // Draw the game behind the upgrade screen
    drawUpgradeScreen();
  } else if (gameState === 'gameover') {
    drawGame();
    drawGameOverScreen();
  } else if (gameState === 'shipSelection') {
    drawShipSelectionScreen();
    }

  // Apply screen shake
  if (screenShake > 0) {
    translate(random(-screenShake, screenShake), random(-screenShake, screenShake));
    screenShake *= 0.9;
    if (screenShake < 0.5) screenShake = 0;
  }
}

function drawDamageNumbers() {
  for (let dn of damageNumbers) {
    push();
    fill(255, dn.alpha);
    textSize(16);
    textAlign(CENTER);
    text(floor(dn.amount), dn.x, dn.y);
    pop();
  }
}

function updateGame() {
  // Update game time (seconds)
  gameTime += 1/60;

  // Update player
  updatePlayer();

  // Update projectiles
  updateProjectiles();

  // Update enemies
  updateEnemies();

  // Update enemy projectiles
  updateEnemyProjectiles();

  // Update particles
  updateParticles();

  // Update pickups
  updatePickups();

  // Update damage numbers
  updateDamageNumbers();

  // Update synergy alerts
  updateSynergyAlerts();

  // Spawn enemies
  if (frameCount % Math.max(30, 120 - level * 5) === 0) {
    spawnEnemy();
  }

  // Check for weapon evolution
  if (frameCount % 60 === 0) { // Check every second
    checkForWeaponEvolution();
  }

  // Spawn boss at intervals
  if (floor(gameTime) > 0 && floor(gameTime) % 180 === 0 && boss === null) {
    spawnBoss();
  }

  // Check for level up
  if (experience >= experienceToNextLevel) {
    levelUp();
  }
}

function updateDamageNumbers() {
  for (let i = damageNumbers.length - 1; i >= 0; i--) {
    let dn = damageNumbers[i];
    dn.y -= 1; // Move up
    dn.lifetime--;
    dn.alpha = 255 * (dn.lifetime / 60); // Fade out

    if (dn.lifetime <= 0) {
      damageNumbers.splice(i, 1);
    }
  }
}

function updatePlayer() {
  player.update();
}


function fireEnemyProjectile(enemy) {
  let angle = atan2(player.y - enemy.y, player.x - enemy.x);
  enemyProjectiles.push({
    x: enemy.x,
    y: enemy.y,
    vx: cos(angle) * 4,
    vy: sin(angle) * 4,
    size: 8,
    damage: enemy.damage,
    color: enemy.color,
    lifetime: 240 // 4 seconds
  });
}

function fireBossProjectile(enemy) {
  let numProjectiles = 12;
  let angleIncrement = TWO_PI / numProjectiles;

  for (let i = 0; i < numProjectiles; i++) {
    let angle = i * angleIncrement;
    enemyProjectiles.push({
      x: enemy.x,
      y: enemy.y,
      vx: cos(angle) * 3,
      vy: sin(angle) * 3,
      size: 12,
      damage: enemy.damage,
      color: enemy.color,
      lifetime: 300
    });
  }
}

function updateEnemyProjectiles() {
  for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
    let p = enemyProjectiles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.lifetime--;

    // Check for collision with player
    if (dist(p.x, p.y, player.x, player.y) < p.size + player.size) {
      player.health -= p.damage;
      player.invulnerable = 30;
      screenShake = 5;
      if (sounds && sounds.playerHit) sounds.playerHit.play();
      enemyProjectiles.splice(i, 1);
      continue;
    }

    if (p.lifetime <= 0 || p.x < 0 || p.x > width || p.y < 0 || p.y > height) {
      enemyProjectiles.splice(i, 1);
    }
  }
}

function updateProjectiles() {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    let p = projectiles[i];
    p.update();

    // Check for collision with enemies
    for (let j = enemies.length - 1; j >= 0; j--) {
      let e = enemies[j];
      let distance = dist(p.x, p.y, e.x, e.y);

      if (distance < p.size + e.size) {
        // Hit enemy
        e.health -= p.damage;
        damageNumbers.push(new DamageNumber(e.x, e.y, p.damage));
        if (sounds && sounds.enemyHit) {
          sounds.enemyHit.rate(random(0.9, 1.1));
          sounds.enemyHit.play();
        }

        // Create hit particles
        for (let k = 0; k < 8; k++) {
          let angle = random(TWO_PI);
          particles.push(new Particle(p.x, p.y, {
            vx: cos(angle) * random(1, 3),
            vy: sin(angle) * random(1, 3),
            size: random(2, 4),
            lifetime: random(10, 20),
            color: e.color,
            alpha: 255
          }));
        }

        // Handle weapon-specific effects
        if (player.synergies.supernova || p.type === 'plasma' || p.type === 'Singularity Cannon') {
          let explosionRadius = (p.type === 'plasma' ? 80 : 60) * p.projectileSize;
          let explosionDamage = p.damage * (p.type === 'plasma' ? 0.5 : 0.3);

          if (p.type === 'Singularity Cannon') {
              // Create a black hole
              particles.push(new Particle(p.x, p.y, {
                  vx: 0, vy: 0,
                  size: 100,
                  lifetime: 300,
                  color: color(0),
                  damaging: true,
                  damage: p.damage * 0.1,
                  pulls: true
              }));
              projectiles.splice(i, 1);
              continue;
          }

          for (let k = enemies.length - 1; k >= 0; k--) {
            if (k === j) continue;
            let otherEnemy = enemies[k];
            if (dist(p.x, p.y, otherEnemy.x, otherEnemy.y) < explosionRadius) {
              otherEnemy.health -= explosionDamage;
              damageNumbers.push(new DamageNumber(otherEnemy.x, otherEnemy.y, explosionDamage));
              if (otherEnemy.health <= 0) {
                killEnemy(k);
              }
            }
          }
        }

        if (p.type === 'plasma' || (player.synergies.supernova && p.type !== 'laser' && p.type !== 'Phasor')) {
          projectiles.splice(i, 1);
        } else if (p.type === 'laser' || p.type === 'Phasor') {
          p.pierce--;
          if (p.pierce <= 0) {
            projectiles.splice(i, 1);
          }
        } else {
          projectiles.splice(i, 1); // Remove non-laser projectiles on hit
        }

        // Check if enemy is dead
        if (e.health <= 0) {
          killEnemy(j);
        }

        if (projectiles[i] !== p) {
          break; // Exit enemy loop if projectile was removed
        }
      }
    }

    // Remove projectile if out of bounds or expired
    if (p.isOffscreen()) {
      projectiles.splice(i, 1);
    }
  }
}

function updateEnemies() {
  for (let i = enemies.length - 1; i >= 0; i--) {
    let e = enemies[i];
    e.update(player);

    // Check for collision with player
    if (player.invulnerable <= 0) {
      let distance = dist(e.x, e.y, player.x, player.y);
      if (distance < e.size + player.size * 0.8) {
        // Player takes damage
        player.health -= e.damage;
        player.invulnerable = 30; // Half a second of invulnerability
        if (sounds && sounds.playerHit) sounds.playerHit.play();

        // Screen shake
        screenShake = 10;

        // Create hit particles
        for (let j = 0; j < 15; j++) {
          let angle = random(TWO_PI);
          particles.push(new Particle(player.x, player.y, {
            vx: cos(angle) * random(2, 5),
            vy: sin(angle) * random(2, 5),
            size: random(3, 6),
            lifetime: random(15, 30),
            color: COLORS.player,
            alpha: 255
          }));
        }

        // Check if player is dead
        if (player.health <= 0) {
          gameOver();
          return;
        }
      }
    }
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    p.update();

    // Check for collision with player if particle is damaging
    if (p.damaging && player.invulnerable <= 0) {
      if (dist(p.x, p.y, player.x, player.y) < p.size + player.size / 2) {
        player.health -= p.damage;
        player.invulnerable = 30;
        screenShake = 3;
        // Do not remove the particle, it can damage multiple times
      }
    }

    if (p.pulls) {
        for (let enemy of enemies) {
            let d = dist(p.x, p.y, enemy.x, enemy.y);
            if (d < p.size * 2) {
                let angle = atan2(p.y - enemy.y, p.x - enemy.x);
                enemy.x += cos(angle) * 2;
                enemy.y += sin(angle) * 2;
            }
        }
    }

    if (p.isDead()) {
      particles.splice(i, 1);
    }
  }
}

function updatePickups() {
  for (let i = pickups.length - 1; i >= 0; i--) {
    let p = pickups[i];

    // Move pickup toward player if close enough
    let distance = dist(p.x, p.y, player.x, player.y);
    if (distance < 150) {
      let angle = atan2(player.y - p.y, player.x - p.x);
      let magnetSpeed = map(distance, 0, 150, 8, 2);
      p.x += cos(angle) * magnetSpeed;
      p.y += sin(angle) * magnetSpeed;
    }

    // Check for collision with player
    if (distance < player.size + p.size) {
      // Collect pickup
      if (p.type === 'experience') {
        experience += p.value;
        if (sounds && sounds.pickupExp) {
          sounds.pickupExp.rate(1 + level * 0.05);
          sounds.pickupExp.play();
        }

        // Create collection particles
        for (let j = 0; j < 8; j++) {
          let angle = random(TWO_PI);
          particles.push(new Particle(p.x, p.y, {
            vx: cos(angle) * random(1, 3),
            vy: sin(angle) * random(1, 3),
            size: random(2, 4),
            lifetime: random(15, 30),
            color: COLORS.experience,
            alpha: 200
          }));
        }
      } else if (p.type === 'health') {
        player.health = min(player.maxHealth, player.health + p.value);
        if (sounds && sounds.pickupHealth) sounds.pickupHealth.play();

        // Create collection particles
        for (let j = 0; j < 8; j++) {
          let angle = random(TWO_PI);
          particles.push(new Particle(p.x, p.y, {
            vx: cos(angle) * random(1, 3),
            vy: sin(angle) * random(1, 3),
            size: random(2, 4),
            lifetime: random(15, 30),
            color: COLORS.health,
            alpha: 200
          }));
        }
      }

      // Remove pickup
      pickups.splice(i, 1);
    }

    // Make pickup float
    p.y += sin(frameCount * 0.1 + p.x) * 0.3;

    // Create floating particles
    if (frameCount % 10 === 0) {
      particles.push(new Particle(p.x + random(-p.size/2, p.size/2), p.y + random(-p.size/2, p.size/2), {
        vx: random(-0.5, 0.5),
        vy: random(-1, -0.5),
        size: random(1, 3),
        lifetime: random(10, 20),
        color: p.type === 'experience' ? COLORS.experience : COLORS.health,
        alpha: 150
      }));
    }
  }
}

function spawnBoss() {
  let spawnEdge = floor(random(4));
  let spawnX, spawnY;

  switch (spawnEdge) {
    case 0: spawnX = width / 2; spawnY = -100; break; // Top
    case 1: spawnX = width + 100; spawnY = height / 2; break; // Right
    case 2: spawnX = width / 2; spawnY = height + 100; break; // Bottom
    case 3: spawnX = -100; spawnY = height / 2; break; // Left
  }

  boss = new Enemy(spawnX, spawnY, 'boss', level);
  enemies.push(boss);
}

function spawnEnemy() {
  // Every 3 seconds, try to spawn a squad
  if (floor(gameTime) % 3 === 0 && frameCount % 60 === 0) {
    if (random() < 0.6) { // 60% chance to spawn a squad
      spawnSquad();
      return; // Don't spawn a single enemy if a squad is spawned
    }
  }

  // Determine spawn position outside the screen
  let spawnX, spawnY;
  let edge = floor(random(4));

  switch (edge) {
    case 0: // Top
      spawnX = random(width);
      spawnY = -20;
      break;
    case 1: // Right
      spawnX = width + 20;
      spawnY = random(height);
      break;
    case 2: // Bottom
      spawnX = random(width);
      spawnY = height + 20;
      break;
    case 3: // Left
      spawnX = -20;
      spawnY = random(height);
      break;
  }

  // Determine enemy type based on game time and randomness
  let enemyType = 'basic';
  let enemySize = random(15, 25);
  let enemyHealth = 30 + level * 5;
  let enemySpeed = random(0.8, 1.5);
  let enemyColor = COLORS.enemy1;
  let enemyDamage = 10;

  if (gameTime > 60 && random() < 0.3) { // After 1 minute, 30% chance of fast enemy
    enemyType = 'fast';
    enemySize = random(10, 18);
    enemyHealth = 20 + level * 3;
    enemySpeed = random(2.0, 2.8);
    enemyColor = COLORS.enemy2;
    enemyDamage = 5;
  }

  if (gameTime > 120 && random() < 0.2) { // After 2 minutes, 20% chance of tank enemy
    enemyType = 'tank';
    enemySize = random(30, 40);
    enemyHealth = 80 + level * 10;
    enemySpeed = random(0.5, 0.8);
    enemyColor = COLORS.enemy3;
    enemyDamage = 20;
  }

  if (gameTime > 240 && random() < 0.15) { // After 4 minutes, 15% chance of trail enemy
    enemyType = 'trail';
    enemySize = random(20, 30);
    enemyHealth = 60 + level * 8;
    enemySpeed = random(1.2, 1.8);
    enemyColor = color(255, 50, 255);
    enemyDamage = 15;
  }

  // Create the enemy
  enemies.push(new Enemy(spawnX, spawnY, enemyType, level));
}

function spawnSquad() {
  let squadType = random(['line', 'v_shape', 'circle', 'ranged_support', 'trail_squad']);
  let spawnEdge = floor(random(4));
  let spawnX, spawnY;
  let numEnemies = floor(random(4, 7));

  // Determine starting position for the squad
  switch (spawnEdge) {
    case 0: spawnX = random(width); spawnY = -50; break; // Top
    case 1: spawnX = width + 50; spawnY = random(height); break; // Right
    case 2: spawnX = random(width); spawnY = height + 50; break; // Bottom
    case 3: spawnX = -50; spawnY = random(height); break; // Left
  }

  for (let i = 0; i < numEnemies; i++) {
    let enemyX = spawnX;
    let enemyY = spawnY;
    let enemyType = 'basic';
    let enemySpeed = random(1, 1.5);

    if (squadType === 'line') {
      // Spawn in a line perpendicular to the spawn edge
      if (spawnEdge === 0 || spawnEdge === 2) { // Top or Bottom
        enemyX = spawnX + (i - numEnemies / 2) * 40;
      } else { // Left or Right
        enemyY = spawnY + (i - numEnemies / 2) * 40;
      }
    } else if (squadType === 'v_shape') {
      // Spawn in a V shape
      if (spawnEdge === 0) { // Top
        enemyX = spawnX + (i - numEnemies / 2) * 40;
        enemyY = spawnY + abs(i - numEnemies / 2) * 30;
      } else { // Bottom
        enemyX = spawnX + (i - numEnemies / 2) * 40;
        enemyY = spawnY - abs(i - numEnemies / 2) * 30;
      }
    } else if (squadType === 'circle') {
      // Spawn in a circular pattern
      let angle = TWO_PI * i / numEnemies;
      enemyX = spawnX + cos(angle) * 50;
      enemyY = spawnY + sin(angle) * 50;
    } else if (squadType === 'ranged_support' && gameTime > 150) {
      // After 2.5 minutes, introduce ranged enemies with support
      if (i < 2) { // Two ranged enemies
        enemyType = 'ranged';
      } else {
        enemyType = 'fast';
      }
    } else if (squadType === 'trail_squad' && gameTime > 300) {
      // After 5 minutes, introduce trail enemies in squads
      enemyType = 'trail';
    }

    let enemySize, enemyHealth, enemyColor, enemyDamage;

    switch (enemyType) {
      case 'ranged':
        enemySize = 20;
        enemyHealth = 40 + level * 4;
        enemyColor = color(255, 150, 0);
        enemyDamage = 15;
        break;
      case 'trail':
        enemySize = random(20, 30);
        enemyHealth = 60 + level * 8;
        enemyColor = color(255, 50, 255);
        enemyDamage = 15;
        break;
      default:
        enemySize = random(15, 25);
        enemyHealth = 30 + level * 5;
        enemyColor = COLORS.enemy1;
        enemyDamage = 10;
    }

    enemies.push(new Enemy(enemyX, enemyY, enemyType, level));
  }
}

function killEnemy(index) {
  let e = enemies[index];

  if (e.type === 'boss') {
    boss = null; // Boss is defeated
    generateBossUpgradeOptions();

    // Massive explosion and drops
    for (let i = 0; i < 100; i++) {
      let angle = random(TWO_PI);
      let speed = random(2, 8);
      particles.push(new Particle(e.x, e.y, {
        vx: cos(angle) * speed,
        vy: sin(angle) * speed,
        size: random(4, 8),
        lifetime: random(40, 80),
        color: e.color,
        alpha: 255
      }));
    }

    // Drop a ton of experience and health
    for (let i = 0; i < 20; i++) {
      pickups.push({
        x: e.x + random(-50, 50), y: e.y + random(-50, 50),
        size: 12, type: 'experience', value: 50
      });
    }
    for (let i = 0; i < 5; i++) {
      pickups.push({
        x: e.x + random(-50, 50), y: e.y + random(-50, 50),
        size: 15, type: 'health', value: 50
      });
    }

    score += 1000;
    kills++;
    enemies.splice(index, 1);
    return; // Avoid normal enemy death logic
  }

  // Create death explosion
  for (let i = 0; i < 20; i++) {
    let angle = random(TWO_PI);
    let speed = random(1, 4);
    particles.push(new Particle(e.x, e.y, {
      vx: cos(angle) * speed,
      vy: sin(angle) * speed,
      size: random(3, 6),
      lifetime: random(20, 40),
      color: e.color,
      alpha: 255
    }));
  }

  // Drop experience
  let expValue = 5;
  if (e.type === 'fast') expValue = 8;
  if (e.type === 'tank') expValue = 15;

  // 100% chance to drop experience
  pickups.push({
    x: e.x,
    y: e.y,
    size: 10,
    type: 'experience',
    value: expValue
  });

  // 10% chance to drop health
  if (random() < 0.1) {
    pickups.push({
      x: e.x + random(-10, 10),
      y: e.y + random(-10, 10),
      size: 10,
      type: 'health',
      value: 15
    });
  }

  // Increase score
  score += expValue;
  kills++;

  // Remove enemy
  enemies.splice(index, 1);
  if (sounds && sounds.enemyDie) {
    sounds.enemyDie.rate(random(0.9, 1.1));
    sounds.enemyDie.play();
  }
}

function levelUp() {
  // Increase level
  level++;
  if (sounds && sounds.levelUp) sounds.levelUp.play();

  // Update experience required for next level
  function levelUp() {
    // Increase level
    level++;
    if (sounds && sounds.levelUp) sounds.levelUp.play();

    // Update experience required for next level
    experience = experience - experienceToNextLevel;
    experienceToNextLevel = 100 + level * 50;

    // Generate upgrade options
    generateUpgradeOptions();

    // Enter upgrade state
    gameState = 'upgrade';
  }
  experience = experience - experienceToNextLevel;
  experienceToNextLevel = 100 + level * 50;

  // Generate upgrade options
  generateUpgradeOptions();

  // Enter upgrade state
  gameState = 'upgrade';
}

function generateUpgradeOptions() {
  upgradeOptions = [];

  // Get available upgrades (not at max level)
  let available = availableUpgrades.filter(upgrade => {
    if (upgrade.name === 'Speed' && player.speed >= 5) return false;
    if (upgrade.name === 'Damage' && player.damage >= 100) return false;
    if (upgrade.name === 'Fire Rate' && player.fireRate <= 100) return false;
    if (upgrade.name === 'Projectile Size' && player.projectileSize >= 3) return false;
    if (upgrade.name === 'Projectile Speed' && player.projectileSpeed >= 12) return false;
    if (upgrade.name === 'Health' && player.maxHealth >= 300) return false;
    if (upgrade.name === 'Multishot' && player.multishot >= 5) return false;
    if (player.takenUpgrades.includes(upgrade.name) && upgrade.maxLevel === 1) return false;
    return true;
  });

  // Add weapon change option if not all weapons discovered
  if (player.upgradeCount >= 3 && weaponTypes.some(type => type !== player.weapon)) {
    let availableWeapons = weaponTypes.filter(type => type !== player.weapon);
    let newWeapon = random(availableWeapons);

    upgradeOptions.push({
      name: 'Change Weapon',
      description: `Change to ${newWeapon} weapon`,
      effect: () => {
        player.weapon = newWeapon;
        currentWeapon = newWeapon;
      }
    });
  }

  // Add 3 random upgrades
  while (upgradeOptions.length < 3 && available.length > 0) {
    let index = floor(random(available.length));
    let upgrade = available[index];

    // Create the upgrade option
    let option = {
        name: upgrade.name,
        description: upgrade.description,
        effect: () => {}
    };

    switch (upgrade.name) {
        case 'Speed':
            option.effect = () => { player.speed *= 1.15; };
            break;
        case 'Damage':
            option.effect = () => { player.damage *= 1.2; };
            break;
        case 'Fire Rate':
            option.effect = () => { player.fireRate = max(100, player.fireRate * 0.85); };
            break;
        case 'Projectile Size':
            option.effect = () => { player.projectileSize *= 1.25; };
            break;
        case 'Projectile Speed':
            option.effect = () => { player.projectileSpeed *= 1.2; };
            break;
        case 'Health':
            option.effect = () => {
                player.maxHealth *= 1.2;
                player.health += player.maxHealth * 0.2;
            };
            break;
        case 'Multishot':
            option.description = player.multishot === 1 ? 'Fire 2 projectiles at once' : 'Add +1 projectile';
            option.effect = () => { player.multishot += 1; };
            break;
        default:
            option.effect = () => {
                if (!player.takenUpgrades.includes(upgrade.name)) {
                    player.takenUpgrades.push(upgrade.name);
                }
            };
            break;
    }
    upgradeOptions.push(option);


    // Remove from available pool
    available.splice(index, 1);
  }
}

function generateBossUpgradeOptions() {
  upgradeOptions = [
    {
      name: 'Ultimate Power',
      description: 'Damage +50%, Fire Rate +25%',
      effect: () => {
        player.damage *= 1.5;
        player.fireRate = max(100, player.fireRate * 0.75);
      }
    },
    {
      name: 'Aegis Shield',
      description: 'Max Health +100%, become invulnerable for 5s',
      effect: () => {
        player.maxHealth *= 2;
        player.health = player.maxHealth;
        player.invulnerable = 300; // 5 seconds
      }
    },
    {
      name: 'Warp Drive',
      description: 'Speed +50%, Multishot +2',
      effect: () => {
        player.speed *= 1.5;
        player.multishot += 2;
      }
    }
  ];
  gameState = 'upgrade';
}

function selectUpgrade(index) {
  if (index >= 0 && index < upgradeOptions.length) {
    // Apply the upgrade effect
    let selectedUpgrade = upgradeOptions[index];
    selectedUpgrade.effect();
    if (sounds && sounds.upgrade) sounds.upgrade.play();

    // Add the upgrade to the player's list of taken upgrades
    if (!player.takenUpgrades.includes(selectedUpgrade.name)) {
      player.takenUpgrades.push(selectedUpgrade.name);
    }

    // Increment upgrade count
    player.upgradeCount++;

    // Check for new synergies
    checkForSynergies();

    // Return to playing
    gameState = 'playing';
  }
}

function checkForSynergies() {
  for (const synergy of synergies) {
    if (!activeSynergies.includes(synergy.name)) {
      const hasAllRequired = synergy.required.every(req => player.takenUpgrades.includes(req));
      if (hasAllRequired) {
        activeSynergies.push(synergy.name);
        synergy.effect(player);
        synergyAlerts.push({ name: synergy.name, description: synergy.description, lifetime: 180 });
      }
    }
  }
}

function checkForWeaponEvolution() {
  const weapon = player.weapon;
  if (evolvedWeapons[weapon]) return;

  const weaponLevel = player.getWeaponLevel();
  if (weaponLevel < 5) return;

  const evolution = weaponEvolutions[weapon];
  if (evolution && player.takenUpgrades.includes(evolution.requiredPassive)) {
    evolvedWeapons[weapon] = true;
    player.weapon = evolution.name;
    synergyAlerts.push({
      name: `EVOLVED: ${evolution.name}`,
      description: evolution.description,
      lifetime: 300
    });
  }
}

function gameOver() {
    gameStats.totalKills += kills;
    if (gameTime > gameStats.longestTime) {
        gameStats.longestTime = gameTime;
    }
  gameState = 'gameover';
  if (sounds && sounds.gameOver) sounds.gameOver.play();
}

function mouseClicked() {
    if (gameState === 'shipSelection') {
        let boxWidth = 250;
        let boxHeight = 150;
        let boxSpacing = 60;
        let totalWidth = ships.length * boxWidth + (ships.length - 1) * boxSpacing;
        let startX = (width - totalWidth) / 2;

        for (let i = 0; i < ships.length; i++) {
            let x = startX + i * (boxWidth + boxSpacing);
            let y = height / 2 - boxHeight / 2;

            if (mouseX >= x && mouseX <= x + boxWidth && mouseY >= y && mouseY <= y + boxHeight) {
                selectShip(i);
                break;
            }
        }
    }
  if (gameState === 'upgrade') {
    // Check if clicked on an upgrade option
    let boxWidth = 200;
    let boxHeight = 100;
    let boxSpacing = 50;
    let totalWidth = upgradeOptions.length * boxWidth + (upgradeOptions.length - 1) * boxSpacing;
    let startX = (width - totalWidth) / 2;

    for (let i = 0; i < upgradeOptions.length; i++) {
      let x = startX + i * (boxWidth + boxSpacing);
      let y = height / 2 - boxHeight / 2;

      if (mouseX >= x && mouseX <= x + boxWidth && mouseY >= y && mouseY <= y + boxHeight) {
        selectUpgrade(i);
        break;
      }
    }
  } else if (gameState === 'gameover') {
    // Restart game
    setup();
  }
}

function keyPressed() {
  // Number keys 1-3 to select upgrade
  if (gameState === 'upgrade' && keyCode >= 49 && keyCode <= 51) {
    let index = keyCode - 49;
    if (index < upgradeOptions.length) {
      selectUpgrade(index);
    }
  }

  // Space to restart game
  if (gameState === 'gameover' && keyCode === 32) {
    setup();
  }
}

function drawGame() {
  // Draw starfield
  drawStarfield();

  // Draw pickups
  drawPickups();

  // Draw particles
  drawParticles();

  // Draw enemies
  drawEnemies();

  // Draw damage numbers
  drawDamageNumbers();

  // Draw projectiles
  drawProjectiles();

  // Draw enemy projectiles
  drawEnemyProjectiles();

  // Draw player
  drawPlayer();

  // Draw UI
  drawUI();

  // Draw synergy alerts
  drawSynergyAlerts();
}

function updateSynergyAlerts() {
  for (let i = synergyAlerts.length - 1; i >= 0; i--) {
    synergyAlerts[i].lifetime--;
    if (synergyAlerts[i].lifetime <= 0) {
      synergyAlerts.splice(i, 1);
    }
  }
}

function drawSynergyAlerts() {
  let yPos = height / 2;
  for (const alert of synergyAlerts) {
    let alpha = alert.lifetime > 60 ? 255 : map(alert.lifetime, 0, 60, 0, 255);

    push();
    textAlign(CENTER, CENTER);

    // Synergy Name
    textSize(32);
    fill(COLORS.uiHighlight, alpha);
    text(`SYNERGY: ${alert.name}`, width / 2, yPos);

    // Synergy Description
    textSize(18);
    fill(COLORS.text, alpha);
    text(alert.description, width / 2, yPos + 40);

    pop();

    yPos -= 100;
  }
}

function drawStarfield() {
  // Draw stars
  for (let star of starfield) {
    fill(star.brightness);
    noStroke();
    ellipse(star.x, star.y, star.size, star.size);

    // Move stars slowly
    star.y += star.speed;

    // Wrap stars
    if (star.y > height) {
      star.y = 0;
      star.x = random(width);
    }
  }
}

function drawPlayer() {
  player.draw();
}

function drawEnemyProjectiles() {
  for (let p of enemyProjectiles) {
    fill(p.color);
    noStroke();
    ellipse(p.x, p.y, p.size * 2, p.size * 2);
  }
}

function drawProjectiles() {
  for (let p of projectiles) {
    p.draw();
  }
}

function drawEnemies() {
  for (let e of enemies) {
    e.draw();
  }
}

function drawParticles() {
  for (let p of particles) {
    p.draw();
  }
}

function drawPickups() {
  for (let p of pickups) {
    push();
    translate(p.x, p.y);

    // Float animation
    let floatY = sin(frameCount * 0.1 + p.x) * 3;
    translate(0, floatY);

    // Rotating animation
    rotate(frameCount * 0.02);

    if (p.type === 'experience') {
      // Experience gem
      noStroke();

      // Glow
      fill(COLORS.experience, 100);
      beginShape();
      for (let i = 0; i < 5; i++) {
        let angle = TWO_PI * i / 5 - HALF_PI;
        let r = p.size * 2;
        let x = cos(angle) * r;
        let y = sin(angle) * r;
        vertex(x, y);

        angle += TWO_PI / 10;
        r = p.size;
        x = cos(angle) * r;
        y = sin(angle) * r;
        vertex(x, y);
      }
      endShape(CLOSE);

      // Crystal
      fill(COLORS.experience);
      beginShape();
      for (let i = 0; i < 5; i++) {
        let angle = TWO_PI * i / 5 - HALF_PI;
        let r = p.size * 1.5;
        let x = cos(angle) * r;
        let y = sin(angle) * r;
        vertex(x, y);

        angle += TWO_PI / 10;
        r = p.size * 0.7;
        x = cos(angle) * r;
        y = sin(angle) * r;
        vertex(x, y);
      }
      endShape(CLOSE);

      // Highlight
      fill(255, 150);
      beginShape();
      for (let i = 0; i < 3; i++) {
        let angle = TWO_PI * i / 3;
        let r = p.size * 0.3;
        let x = cos(angle) * r;
        let y = sin(angle) * r;
        vertex(x, y);
      }
      endShape(CLOSE);

    } else if (p.type === 'health') {
      // Health pickup
      // Glow
      noStroke();
      fill(COLORS.health, 100);
      ellipse(0, 0, p.size * 2.5, p.size * 2.5);

      // Cross
      fill(COLORS.health);
      rectMode(CENTER);
      rect(0, 0, p.size * 1.8, p.size * 0.7);
      rect(0, 0, p.size * 0.7, p.size * 1.8);

      // Highlight
      fill(255, 150);
      ellipse(-p.size * 0.3, -p.size * 0.3, p.size * 0.4, p.size * 0.4);
    }

    pop();
  }
}

function drawUI() {
  // Experience bar
  let expBarWidth = width - 40;
  let expBarHeight = 10;
  let expBarX = 20;
  let expBarY = height - 20;

  noStroke();
  fill(COLORS.uiBackground);
  rect(expBarX, expBarY, expBarWidth, expBarHeight, expBarHeight / 2);

  let expPercent = experience / experienceToNextLevel;
  fill(COLORS.experience);
  rect(expBarX, expBarY, expBarWidth * expPercent, expBarHeight, expBarHeight / 2);

  // Level indicator
  textAlign(LEFT, BOTTOM);
  fill(COLORS.text);
  textSize(18);
  text(`Level ${level}`, expBarX, expBarY - 5);

  // Experience text
  textAlign(RIGHT, BOTTOM);
  text(`${experience}/${experienceToNextLevel} XP`, expBarX + expBarWidth, expBarY - 5);

  // Health bar
  let healthBarWidth = 200;
  let healthBarHeight = 20;
  let healthBarX = 20;
  let healthBarY = 20;

  noStroke();
  fill(COLORS.uiBackground);
  rect(healthBarX, healthBarY, healthBarWidth, healthBarHeight, healthBarHeight / 2);

  let healthPercent = player.health / player.maxHealth;
  fill(COLORS.health);
  rect(healthBarX, healthBarY, healthBarWidth * healthPercent, healthBarHeight, healthBarHeight / 2);

  // Health text
  textAlign(CENTER, CENTER);
  fill(COLORS.text);
  textSize(14);
  text(`${ceil(player.health)}/${ceil(player.maxHealth)}`, healthBarX + healthBarWidth / 2, healthBarY + healthBarHeight / 2);

  // Score and time
  textAlign(RIGHT, TOP);
  fill(COLORS.text);
  textSize(18);
  text(`Score: ${score}`, width - 20, 20);
  text(`Time: ${formatTime(gameTime)}`, width - 20, 45);
  text(`Kills: ${kills}`, width - 20, 70);

  // Weapon indicator
  textAlign(LEFT, TOP);
  let weaponName = evolvedWeapons[currentWeapon] ? weaponEvolutions[currentWeapon].name : currentWeapon.charAt(0).toUpperCase() + currentWeapon.slice(1);
  if (evolvedWeapons[currentWeapon]) {
      fill(COLORS.uiHighlight);
      textSize(20);
      text(`EVOLVED: ${weaponName}`, healthBarX + healthBarWidth + 20, healthBarY + 10);
  } else {
      fill(COLORS.text);
      textSize(18);
      text(`Weapon: ${weaponName}`, healthBarX + healthBarWidth + 20, healthBarY);
  }

  // Stats
  let statX = healthBarX + healthBarWidth + 20;
  let statY = healthBarY + 25;
  let statSpacing = 20;

  textSize(14);
  text(`Damage: ${player.damage}`, statX, statY);
  text(`Fire Rate: ${(1000 / player.fireRate).toFixed(1)}/s`, statX, statY + statSpacing);
  text(`Speed: ${player.speed.toFixed(1)}`, statX, statY + statSpacing * 2);

  // Boss health bar
  if (boss) {
    let barWidth = width - 200;
    let barHeight = 20;
    let barX = 100;
    let barY = 20;

    // Boss name
    textAlign(CENTER, BOTTOM);
    textSize(20);
    fill(COLORS.boss);
    text('!! MEGA-MECH MANTIS !!', width / 2, barY - 5);

    // Health bar
    noStroke();
    fill(COLORS.uiBackground);
    rect(barX, barY, barWidth, barHeight);

    let healthPercent = boss.health / boss.maxHealth;
    fill(COLORS.boss);
    rect(barX, barY, barWidth * healthPercent, barHeight);

    // Health text
    textAlign(CENTER, CENTER);
    fill(COLORS.text);
    textSize(14);
    text(`${ceil(boss.health)} / ${ceil(boss.maxHealth)}`, width / 2, barY + barHeight / 2);
  }
}

function formatTime(seconds) {
  let minutes = floor(seconds / 60);
  seconds = floor(seconds % 60);
  return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
}

function drawUpgradeScreen() {
  // Darken background
  fill(0, 0, 0, 150);
  rect(0, 0, width, height);

  // Title
  textAlign(CENTER, CENTER);
  fill(COLORS.text);
  textSize(36);
  text('LEVEL UP!', width / 2, height / 4);
  textSize(18);
  text('Choose an upgrade:', width / 2, height / 4 + 40);

  // Draw upgrade options
  let boxWidth = 200;
  let boxHeight = 100;
  let boxSpacing = 50;
  let totalWidth = upgradeOptions.length * boxWidth + (upgradeOptions.length - 1) * boxSpacing;
  let startX = (width - totalWidth) / 2;

  for (let i = 0; i < upgradeOptions.length; i++) {
    let option = upgradeOptions[i];
    let x = startX + i * (boxWidth + boxSpacing);
    let y = height / 2 - boxHeight / 2;

    // Check if mouse is over this option
    let isHovered = mouseX >= x && mouseX <= x + boxWidth && mouseY >= y && mouseY <= y + boxHeight;

    // Draw box
    fill(COLORS.uiBackground);
    if (isHovered) {
      stroke(COLORS.uiHighlight);
      strokeWeight(3);
    } else {
      noStroke();
    }
    rect(x, y, boxWidth, boxHeight, 10);

    // Draw option text
    textAlign(CENTER, CENTER);
    noStroke();
    fill(isHovered ? COLORS.uiHighlight : COLORS.text);
    textSize(20);
    text(option.name, x + boxWidth / 2, y + 30);

    textSize(14);
    text(option.description, x + boxWidth / 2, y + 60);

    // Draw keybind
    textSize(12);
    fill(COLORS.text, 150);
    text(`Press ${i + 1}`, x + boxWidth / 2, y + boxHeight - 15);
  }
}

function drawGameOverScreen() {
  // Darken background
  fill(0, 0, 0, 200);
  rect(0, 0, width, height);

  // Game over text
  textAlign(CENTER, CENTER);
  fill(COLORS.text);
  textSize(48);
  text('GAME OVER', width / 2, height / 3);

  // Stats
  textSize(24);
  text(`Time Survived: ${formatTime(gameTime)}`, width / 2, height / 2);
  text(`Score: ${score}`, width / 2, height / 2 + 40);
  text(`Enemies Killed: ${kills}`, width / 2, height / 2 + 80);
  text(`Level Reached: ${level}`, width / 2, height / 2 + 120);

  // Restart prompt
  textSize(18);
  fill(COLORS.uiHighlight);
  text('Press SPACE to restart', width / 2, height * 3 / 4);
}

function selectShip(index) {
    if (index >= 0 && index < ships.length) {
        let ship = ships[index];
        if (!ship.unlockCondition(gameStats)) return;

        currentWeapon = ship.startingWeapon;
        player.weapon = ship.startingWeapon;

        if (ship.trait) {
            if (ship.trait.health) player.maxHealth *= ship.trait.health;
            if (ship.trait.damage) player.damage *= ship.trait.damage;
            if (ship.trait.speed) player.speed *= ship.trait.speed;
            if (ship.trait.fireRate) player.fireRate *= ship.trait.fireRate;
        }

        player.health = player.maxHealth;
        gameState = 'playing';
    }
}

function drawShipSelectionScreen() {
    background(COLORS.background);
    textAlign(CENTER, CENTER);
    fill(COLORS.text);
    textSize(36);
    text('SELECT YOUR SHIP', width / 2, height / 8);

    let boxWidth = 250;
    let boxHeight = 150;
    let boxSpacing = 60;
    let totalWidth = ships.length * boxWidth + (ships.length - 1) * boxSpacing;
    let startX = (width - totalWidth) / 2;

    for (let i = 0; i < ships.length; i++) {
        let ship = ships[i];
        let x = startX + i * (boxWidth + boxSpacing);
        let y = height / 2 - boxHeight / 2;

        let isHovered = mouseX >= x && mouseX <= x + boxWidth && mouseY >= y && mouseY <= y + boxHeight;
        let isUnlocked = ship.unlockCondition(gameStats);

        fill(isUnlocked ? COLORS.uiBackground : color(50));
        if (isHovered && isUnlocked) {
            stroke(COLORS.uiHighlight);
            strokeWeight(3);
        } else {
            noStroke();
        }
        rect(x, y, boxWidth, boxHeight, 10);

        textAlign(CENTER, CENTER);
        noStroke();
        fill(isHovered ? COLORS.uiHighlight : COLORS.text);
        textSize(24);
        text(ship.name, x + boxWidth / 2, y + 30);

        textSize(16);
        text(ship.description, x + boxWidth / 2, y + 70);

        textSize(14);
        fill(COLORS.text, 150);
        text(`Starts with: ${ship.startingWeapon}`, x + boxWidth / 2, y + boxHeight - 25);
    }
}

const RANGED_ENEMY_COOLDOWN = 2000;
const BOSS_ATTACK_COOLDOWN = 2000;
const TRAIL_PARTICLE_LIFETIME = 180;

class Player {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.size = 24;
    this.speed = 3;
    this.health = 100;
    this.maxHealth = 100;
    this.damage = 20;
    this.fireRate = 300; // milliseconds between shots
    this.lastFired = 0;
    this.projectileSize = 1;
    this.projectileSpeed = 5;
    this.multishot = 1;
    this.upgradeCount = 0;
    this.invulnerable = 0; // invulnerability timer
    this.angle = 0; // facing angle
    this.weapon = currentWeapon;
    this.takenUpgrades = [];
    this.synergies = {};
    this.weaponLevels = {
        laser: 0,
        plasma: 0,
        wave: 0
    };
  }

  getWeaponLevel() {
    return this.weaponLevels[this.weapon] || 0;
  }

  update() {
    // Handle player movement
    let dx = 0;
    let dy = 0;

    if (keyIsDown(87) || keyIsDown(UP_ARROW)) dy -= 1; // W or Up arrow
    if (keyIsDown(83) || keyIsDown(DOWN_ARROW)) dy += 1; // S or Down arrow
    if (keyIsDown(65) || keyIsDown(LEFT_ARROW)) dx -= 1; // A or Left arrow
    if (keyIsDown(68) || keyIsDown(RIGHT_ARROW)) dx += 1; // D or Right arrow

    // Normalize diagonal movement
    if (dx !== 0 && dy !== 0) {
      dx *= 0.7071; // 1/sqrt(2)
      dy *= 0.7071;
    }

    this.x += dx * this.speed;
    this.y += dy * this.speed;

    // Keep player in bounds
    this.x = constrain(this.x, this.size, width - this.size);
    this.y = constrain(this.y, this.size, height - this.size);

    // Update player angle to face mouse
    if (mouseX !== 0 && mouseY !== 0) {
      this.angle = atan2(mouseY - this.y, mouseX - this.x);
    }

    // Auto fire
    if (millis() - this.lastFired > this.fireRate) {
      this.fire();
      this.lastFired = millis();
      if (sounds) {
        if (this.weapon === 'laser' && sounds.shootLaser) sounds.shootLaser.play();
        else if (this.weapon === 'plasma' && sounds.shootPlasma) sounds.shootPlasma.play();
        else if (this.weapon === 'wave' && sounds.shootWave) sounds.shootWave.play();
      }
    }

    // Decrease invulnerability timer
    if (this.invulnerable > 0) {
      this.invulnerable--;
    }
  }

  fire() {
    let baseAngle = atan2(mouseY - this.y, mouseX - this.x);

    if (this.weapon === 'wave' || this.weapon === 'Resonance Blaster') {
      let angleSpread = PI / 2; // Wide 90-degree arc
      let numProjectiles = 5 + this.multishot * 2; // More projectiles for a denser wave
      for (let i = 0; i < numProjectiles; i++) {
        let angle = baseAngle - angleSpread / 2 + (angleSpread * i / (numProjectiles - 1));
        projectiles.push(new Projectile(this.x, this.y, angle, this));
      }
    } else {
      // Calculate spread based on multishot for laser and plasma
      let angleSpread = 0;
      if (this.multishot > 1) {
        angleSpread = PI / 8;
      }

      for (let i = 0; i < this.multishot; i++) {
        let angle = baseAngle;

        // If we have multiple shots, adjust the angle
        if (this.multishot > 1) {
          angle = baseAngle - angleSpread/2 + (angleSpread * i / (this.multishot - 1));
        }

        projectiles.push(new Projectile(this.x, this.y, angle, this));

        // Add muzzle flash particle
        let flashColor;
        switch (this.weapon) {
          case 'laser': flashColor = COLORS.projectileLaser; break;
          case 'plasma': flashColor = COLORS.projectilePlasma; break;
          case 'wave': flashColor = COLORS.projectileWave; break;
          case 'Phasor': flashColor = color(255, 100, 100); break;
          case 'Singularity Cannon': flashColor = color(150, 50, 255); break;
          case 'Resonance Blaster': flashColor = color(100, 255, 255); break;
        }

        for (let j = 0; j < 3; j++) {
          particles.push(new Particle(this.x + cos(angle) * this.size, this.y + sin(angle) * this.size, {
            vx: cos(angle) * random(1, 3) + random(-1, 1),
            vy: sin(angle) * random(1, 3) + random(-1, 1),
            size: random(2, 5),
            lifetime: random(10, 20),
            color: flashColor,
            alpha: 255
          }));
        }
      }
    }
  }

  draw() {
    push();
    translate(this.x, this.y);
    rotate(this.angle);

    // Draw player shadow/glow
    fill(COLORS.playerShadow);
    noStroke();

    // Pulse effect for shield when invulnerable
    if (this.invulnerable > 0) {
      let pulseSize = 1.2 + sin(frameCount * 0.2) * 0.1;
      ellipse(0, 0, this.size * 2 * pulseSize, this.size * 2 * pulseSize);
    }

    // Draw ship base
    fill(COLORS.player);
    beginShape();
    vertex(this.size, 0);
    vertex(-this.size/2, this.size/2);
    vertex(-this.size/4, 0);
    vertex(-this.size/2, -this.size/2);
    endShape(CLOSE);

    // Draw cockpit
    fill(COLORS.background);
    ellipse(this.size/4, 0, this.size/2, this.size/3);

    // Draw engine glow
    fill(COLORS.projectileLaser);
    ellipse(-this.size/3, 0, this.size/3, this.size/6);

    pop();
  }
}

class Projectile {
  constructor(x, y, angle, owner) {
    this.x = x;
    this.y = y;
    this.angle = angle;
    this.owner = owner;
    this.type = owner.weapon;
    this.projectileSize = owner.projectileSize;
    this.damage = owner.damage;
    this.speed = owner.projectileSpeed;

    if (this.type === 'wave') {
        this.speed *= 0.8;
        this.damage *= 0.7;
        this.lifetime = 45;
        this.size = 8 * this.projectileSize;
    } else if (this.type === 'Phasor') {
        this.speed *= 1.5;
        this.damage *= 0.5;
        this.lifetime = 20;
        this.size = 20 * this.projectileSize;
        this.pierce = Infinity;
    } else if (this.type === 'Singularity Cannon') {
        this.speed *= 0.5;
        this.lifetime = 300;
        this.size = 15 * this.projectileSize;
    } else if (this.type === 'Resonance Blaster') {
        this.speed *= 0.7;
        this.damage *= 0.8;
        this.lifetime = 240;
        this.size = 10 * this.projectileSize;
        this.bounces = 3;
    } else {
        this.lifetime = 180; // frames
        this.size = 6 * this.projectileSize;
    }

    if (this.type === 'laser') {
        this.pierce = 3;
    }

    this.vx = cos(angle) * this.speed;
    this.vy = sin(angle) * this.speed;
  }

  update() {
    // Move projectile
    this.x += this.vx;
    this.y += this.vy;

    if (this.type === 'Resonance Blaster') {
        if (this.x < 0 || this.x > width) {
            this.vx *= -1;
            this.bounces--;
        }
        if (this.y < 0 || this.y > height) {
            this.vy *= -1;
            this.bounces--;
        }
        if (this.bounces < 0) {
            this.lifetime = 0;
        }
    }

    // Create trail particles
    if (frameCount % 2 === 0) {
      let trailColor;
      switch (this.type) {
        case 'laser': trailColor = COLORS.projectileLaser; break;
        case 'plasma': trailColor = COLORS.projectilePlasma; break;
        case 'wave': trailColor = COLORS.projectileWave; break;
        case 'Phasor': trailColor = color(255, 100, 100); break;
        case 'Singularity Cannon': trailColor = color(150, 50, 255); break;
        case 'Resonance Blaster': trailColor = color(100, 255, 255); break;
      }

      particles.push(new Particle(this.x, this.y, {
        vx: random(-0.5, 0.5),
        vy: random(-0.5, 0.5),
        size: random(1, 3) * this.projectileSize,
        lifetime: random(10, 20),
        color: trailColor,
        alpha: 150
      }));
    }
    this.lifetime--;
  }

  draw() {
    push();
    translate(this.x, this.y);
    rotate(this.angle);

    // Different projectile types
    if (this.type === 'laser') {
      stroke(COLORS.projectileLaser);
      strokeWeight(this.size);
      line(0, 0, -this.size * 3, 0);

      noStroke();
      fill(COLORS.projectileLaser);
      ellipse(0, 0, this.size * 1.5, this.size);
    } else if (this.type === 'plasma') {
      noStroke();
      for (let i = 3; i > 0; i--) {
        let alpha = 255 - (i * 40);
        fill(COLORS.projectilePlasma, alpha);
        ellipse(0, 0, this.size * (1 + i * 0.3), this.size * (1 + i * 0.3));
      }
      fill(255);
      ellipse(0, 0, this.size * 0.5, this.size * 0.5);
    } else if (this.type === 'wave') {
      noFill();
      stroke(COLORS.projectileWave, 200);
      strokeWeight(this.size * 0.5);
      let arcSize = this.size * 2;
      arc(0, 0, arcSize, arcSize, -PI/4, PI/4);
    } else if (this.type === 'Phasor') {
        stroke(255, 100, 100, 150);
        strokeWeight(this.size);
        line(0, 0, -this.size * 5, 0);
    } else if (this.type === 'Singularity Cannon') {
        noStroke();
        fill(150, 50, 255, 100);
        ellipse(0, 0, this.size * 2, this.size * 2);
        fill(0);
        ellipse(0, 0, this.size, this.size);
    } else if (this.type === 'Resonance Blaster') {
        noFill();
        stroke(100, 255, 255, 200);
        strokeWeight(this.size * 0.3);
        ellipse(0, 0, this.size * 2, this.size * 2);
    }


    pop();
  }

  isOffscreen() {
    return (this.x < 0 || this.x > width || this.y < 0 || this.y > height || this.lifetime <= 0);
  }
}

class Enemy {
  constructor(x, y, type, level) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.pulseTime = random(TWO_PI);
    this.lastFired = 0;
    this.angle = 0;

    // Properties based on type
    switch (type) {
      case 'fast':
        this.size = random(10, 18);
        this.health = 20 + level * 3;
        this.speed = random(2.0, 2.8);
        this.color = COLORS.enemy2;
        this.damage = 5;
        break;
      case 'tank':
        this.size = random(30, 40);
        this.health = 80 + level * 10;
        this.speed = random(0.5, 0.8);
        this.color = COLORS.enemy3;
        this.damage = 20;
        break;
      case 'trail':
        this.size = random(20, 30);
        this.health = 60 + level * 8;
        this.speed = random(1.2, 1.8);
        this.color = color(255, 50, 255);
        this.damage = 15;
        break;
      case 'ranged':
        this.size = 20;
        this.health = 40 + level * 4;
        this.speed = random(1, 1.5);
        this.color = color(255, 150, 0);
        this.damage = 15;
        this.attackCooldown = RANGED_ENEMY_COOLDOWN;
        break;
      case 'boss':
        this.size = 80;
        this.health = 2000 + level * 500;
        this.speed = 0.8;
        this.color = COLORS.boss;
        this.damage = 50;
        this.attackCooldown = BOSS_ATTACK_COOLDOWN;
        this.attackPattern = 'circle';
        this.lastFired = 0;
        break;
      default: // basic
        this.size = random(15, 25);
        this.health = 30 + level * 5;
        this.speed = random(0.8, 1.5);
        this.color = COLORS.enemy1;
        this.damage = 10;
        break;
    }
    this.maxHealth = this.health;
    this.speed *= (1 + level * 0.05);
  }

  update(player) {
    // Boss AI
    if (this.type === 'boss') {
      let distanceToPlayer = dist(this.x, this.y, player.x, player.y);
      if (distanceToPlayer > 300) {
        let angle = atan2(player.y - this.y, player.x - this.x);
        this.x += cos(angle) * this.speed;
        this.y += sin(angle) * this.speed;
        this.angle = angle;
      } else {
        // Strafe
        let angle = atan2(player.y - this.y, player.x - this.x) + HALF_PI;
        this.x += cos(angle) * this.speed * 0.5;
        this.y += sin(angle) * this.speed * 0.5;
        this.angle = atan2(player.y - this.y, player.x - this.x);
      }
    } else {
        // Move enemy toward player
        let angle = atan2(player.y - this.y, player.x - this.x);
        this.x += cos(angle) * this.speed;
        this.y += sin(angle) * this.speed;
        this.angle = angle;
    }


    // Ranged enemies fire projectiles
    if (this.type === 'ranged' && millis() - this.lastFired > this.attackCooldown) {
      fireEnemyProjectile(this);
      this.lastFired = millis();
    } else if (this.type === 'boss' && millis() - this.lastFired > this.attackCooldown) {
      fireBossProjectile(this);
      this.lastFired = millis();
    }

    // Leave trail
    if (this.type === 'trail' && frameCount % 5 === 0) {
        particles.push(new Particle(this.x, this.y, {
            vx: 0,
            vy: 0,
            size: this.size * 1.5,
            lifetime: TRAIL_PARTICLE_LIFETIME,
            color: this.color,
            alpha: 150,
            damaging: true,
            damage: 5
        }));
    } else if (frameCount % 10 === 0) {
        particles.push(new Particle(this.x, this.y, {
            vx: random(-0.5, 0.5),
            vy: random(-0.5, 0.5),
            size: random(2, 4),
            lifetime: random(10, 20),
            color: this.color,
            alpha: 100
        }));
    }
  }

  draw() {
    push();
    translate(this.x, this.y);
    rotate(this.angle);

    // Draw health bar
    let healthPercent = this.health / this.maxHealth;

    if (healthPercent < 1) {
      push();
      translate(0, -this.size - 10);
      noStroke();
      fill(100, 100, 100, 150);
      rect(-this.size, -2, this.size * 2, 4);
      fill(255, 0, 50, 200);
      rect(-this.size, -2, this.size * 2 * healthPercent, 4);
      pop();
    }

    // Different enemy types
    if (this.type === 'basic') {
      noStroke();
      this.pulseTime += 0.05;
      let pulse = 1 + sin(this.pulseTime) * 0.1;

      fill(this.color, 50);
      ellipse(0, 0, this.size * 2.5 * pulse, this.size * 2.5 * pulse);

      fill(this.color);
      beginShape();
      vertex(this.size, 0);
      vertex(-this.size, this.size);
      vertex(-this.size/2, 0);
      vertex(-this.size, -this.size);
      endShape(CLOSE);

      fill(255);
      ellipse(this.size / 2, 0, this.size / 2, this.size / 2);
      fill(0);
      ellipse(this.size / 2, 0, this.size / 4, this.size / 4);

    } else if (this.type === 'fast') {
      noStroke();

      fill(this.color, 50);
      ellipse(-this.size, 0, this.size * 3, this.size);

      fill(this.color);
      beginShape();
      vertex(this.size, 0);
      vertex(-this.size, this.size / 2);
      vertex(-this.size, -this.size / 2);
      endShape(CLOSE);

      stroke(255, 200);
      strokeWeight(1);
      line(-this.size / 2, -this.size / 4, this.size / 2, -this.size / 4);
      line(-this.size / 2, this.size / 4, this.size / 2, this.size / 4);

    } else if (this.type === 'tank') {
      this.pulseTime += 0.03;
      let pulse = 1 + sin(this.pulseTime) * 0.1;

      noStroke();
      fill(this.color, 40);
      ellipse(0, 0, this.size * 2.2 * pulse, this.size * 2.2 * pulse);

      fill(this.color);
      ellipse(0, 0, this.size * 1.8, this.size * 1.8);

      fill(COLORS.background);
      arc(0, 0, this.size * 1.4, this.size * 1.4, PI / 6, PI - PI / 6, PIE);
      arc(0, 0, this.size * 1.4, this.size * 1.4, PI + PI / 6, TWO_PI - PI / 6, PIE);

      fill(255);
      ellipse(0, 0, this.size * 0.6, this.size * 0.6);

      fill(this.color);
      ellipse(0, 0, this.size * 0.4 * pulse, this.size * 0.4 * pulse);
    } else if (this.type === 'boss') {
      this.pulseTime += 0.02;
      let pulse = 1 + sin(this.pulseTime) * 0.05;

      noStroke();
      fill(this.color, 30);
      ellipse(0, 0, this.size * 2.5 * pulse, this.size * 2.5 * pulse);

      push();
      rotate(this.pulseTime * 0.5);
      fill(this.color, 150);
      for(let i = 0; i < 4; i++) {
        rect(-this.size * 0.8, -this.size * 0.1, this.size * 1.6, this.size * 0.2);
        rotate(HALF_PI);
      }
      pop();

      fill(COLORS.background);
      stroke(this.color);
      strokeWeight(4);
      ellipse(0, 0, this.size * 1.2, this.size * 1.2);

      fill(this.color);
      noStroke();
      ellipse(0, 0, this.size * 0.5, this.size * 0.5);
      fill(255, 255, 0);
      ellipse(0, 0, this.size * 0.3 * pulse, this.size * 0.3 * pulse);
    }

    pop();
  }
}

class Particle {
  constructor(x, y, options) {
    this.x = x;
    this.y = y;
    this.vx = options.vx || random(-1, 1);
    this.vy = options.vy || random(-1, 1);
    this.size = options.size || random(2, 5);
    this.lifetime = options.lifetime || random(10, 30);
    this.color = options.color || color(255);
    this.alpha = options.alpha || 255;
    this.damaging = options.damaging || false;
    this.damage = options.damage || 0;
    this.pulls = options.pulls || false;
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.alpha = this.alpha * (this.lifetime / (this.lifetime + 1));
    this.lifetime--;
  }

  draw() {
    noStroke();
    fill(this.color, this.alpha);
    ellipse(this.x, this.y, this.size, this.size);
  }

  isDead() {
    return this.lifetime <= 0;
  }
}
    </script>
</body>
</html>
